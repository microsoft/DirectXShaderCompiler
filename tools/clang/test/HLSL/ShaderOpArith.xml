<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<ShaderOpSet xmlns="http://schemas.microsoft.com/test/ShaderOp">
  <ShaderOp Name="DerivFine" PS="PS" VS="VS" TopologyType="TRIANGLE">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), DescriptorTable(SRV(t0,numDescriptors=1))</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="T0" Dimension="Texture2D" Width="4" Height="4" InitialResourceState="COPY_DEST" Init="FromBytes" Format="R32_FLOAT">
      {.125f, .25f, .5f, 1.0f},
      {2.0f, 4.0f, 16.0f, 32.0f},
      {32.0f, 64.0f, 128.0f, 256.0f},
      {256.0f, 512.0f, 1024.0f, 2048.0f}
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_0">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        PSInput main(float3 position : POSITION, float2 uv : TEXCOORD) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          return result;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_0">
      <![CDATA[
      struct PSInput {
        float4 position : SV_POSITION;
        float2 uv : TEXCOORD;
      };

      Texture2D<float> g_tex : register(t0);

      float4 main(PSInput input) : SV_TARGET {
        int3 offset = int3((input.uv * 64.0) % 4, 0);
        float val = g_tex.Load(offset);
        return float4(ddx_fine(val), ddy_fine(val), ddx_coarse(val), ddy_coarse(val));
      }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="WriteFloat4" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>

    <Resource Name="Buffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="Zero" ReadBack="true" TransitionTo="UNORDERED_ACCESS" />

    <RootValues>
      <RootValue Index="0" ResName="Buffer" />
    </RootValues>

    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    RWStructuredBuffer<float4> g_buf : register(u0);
    [numthreads(8,8,1)]
    void main(uint GI : SV_GroupIndex) {
      g_buf[GI] = GI;
    };
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Derivatives" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(SRV(t0,numDescriptors=1), UAV(u0), UAV(u1), UAV(u2)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="T0" Dimension="Texture2D" Width="4" Height="4" InitialResourceState="COPY_DEST" Init="FromBytes" Format="R32_FLOAT">
      {.125f, .25f, .5f, 1.0f},
      {2.0f, 4.0f, 16.0f, 32.0f},
      {32.0f, 64.0f, 128.0f, 256.0f},
      {256.0f, 512.0f, 1024.0f, 2048.0f}
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="32" Height="32" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <Resource Name="U0" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U1' Kind='UAV' ResName='U1'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U2' Kind='UAV' ResName='U2'
                  NumElements="1024" StructureByteStride="16" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="CS" Target="cs_6_6" EntryPoint="CSMain" Text="@PS"/>
    <Shader Name="AS" Target="as_6_6" EntryPoint="ASMain" Text="@PS"/>
    <Shader Name="MS" Target="ms_6_6" EntryPoint="MSMain" Text="@PS"/>
    <Shader Name="VS" Target="vs_6_0" EntryPoint="VSMain" Text="@PS"/>
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        Texture2D<float> g_tex : register(t0);
        RWStructuredBuffer<float4> g_bufMain : register(u0);
        RWStructuredBuffer<float4> g_bufMesh : register(u1);
        RWStructuredBuffer<float4> g_bufAmp : register(u2);

        float4 DerivTest(int2 uv) {
          int3 offset = int3(uv%4, 0);
          float val = g_tex.Load(offset);
          return float4(ddx_fine(val), ddy_fine(val), ddx_coarse(val), ddy_coarse(val));
        }

        // Convert single index into uv and test derivatives
        float4 DerivTest(uint ix) {
          return DerivTest(int2(((ix&0x4)>>1) + (ix&01), ((ix&0x8)>>2) + ((ix&02)>>1)));
        }

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          return result;
        }

        struct Payload {
          uint nothing;
        };

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          g_bufAmp[ix] = DerivTest(ix);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            verts[ix].position = g_Verts[ix];
            verts[ix].uv = g_UV[ix];
            if (ix % 3)
              tris[ix / 3] = uint3(ix, ix + 1, ix + 2);
            g_bufMesh[ix] = DerivTest(ix);
        }
        float4 PSMain(PSInput input) : SV_TARGET {
          float4 res = DerivTest(input.uv * 32.0);
          int ix = input.uv.y * 32 * 32 + input.uv.x * 32;
          g_bufMain[ix] = res;
          return res;
        }

        [NumThreads(DISPATCHX, DISPATCHY, DISPATCHZ)]
        void CSMain(uint ix : SV_GroupIndex) {
          g_bufMain[ix] = DerivTest(ix);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="QuadRead" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(UAV(u0), UAV(u1), UAV(u2))
    </RootSignature>
    <Resource Name="U0" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U1' Kind='UAV' ResName='U1'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U2' Kind='UAV' ResName='U2'
                  NumElements="1024" StructureByteStride="16" />
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <Shader Name="CS" Target="cs_6_0" EntryPoint="CSMain" Text="@PS"/>
    <Shader Name="AS" Target="as_6_6" EntryPoint="ASMain" Text="@PS"/>
    <Shader Name="MS" Target="ms_6_6" EntryPoint="MSMain" Text="@PS"/>
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
        };
        RWStructuredBuffer<int4> g_bufMain : register(u0);
        RWStructuredBuffer<int4> g_bufMesh : register(u1);
        RWStructuredBuffer<int4> g_bufAmp : register(u2);

        uint4 QuadReadTest(uint ix) {
          return int4(QuadReadLaneAt(ix, ix & 0x3), QuadReadAcrossX(ix),
                      QuadReadAcrossY(ix), QuadReadAcrossDiagonal(ix));
        }

        struct Payload {
          uint nothing;
        };

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          g_bufAmp[ix] = QuadReadTest(ix);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            verts[ix].position = g_Verts[ix];
            if (ix % 3)
              tris[ix / 3] = uint3(ix, ix + 1, ix + 2);
            g_bufMesh[ix] = QuadReadTest(ix);
        }

        void PSMain(PSInput input) {
          return;
        }

        [NumThreads(DISPATCHX, DISPATCHY, DISPATCHZ)]
        void CSMain(uint ix : SV_GroupIndex) {
          g_bufMain[ix] = QuadReadTest(ix);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="ComputeSample" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(SRV(t0,numDescriptors=1), UAV(u0), UAV(u1), UAV(u2)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="T0" Dimension="Texture2D" Width="64" Height="64" MipLevels="7" InitialResourceState="COPY_DEST" Init="ByName" Format="R32_FLOAT" />
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="8" Height="8" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" />
    <Resource Name="U0" Dimension="BUFFER" Width="1920"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="1920"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="1920"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="64" StructureByteStride="16" />
      <Descriptor Name='U1' Kind='UAV' ResName='U1'
                  NumElements="64" StructureByteStride="16" />
      <Descriptor Name='U2' Kind='UAV' ResName='U2'
                  NumElements="64" StructureByteStride="16" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="CS" Target="cs_6_6" EntryPoint="CSMain" Text="@PS"/>
    <Shader Name="AS" Target="as_6_6" EntryPoint="ASMain" Text="@PS"/>
    <Shader Name="MS" Target="ms_6_6" EntryPoint="MSMain" Text="@PS"/>
    <Shader Name="VS" Target="vs_6_0" EntryPoint="VSMain" Text="@PS"/>
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };

        Texture2D<float> g_tex : register(t0);
        RWStructuredBuffer<float4> g_bufMain : register(u0);
        RWStructuredBuffer<float4> g_bufMesh : register(u1);
        RWStructuredBuffer<float4> g_bufAmp : register(u2);

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          return result;
        }

        SamplerState g_samp : register(s0);

        uint4 DerivTest(uint ix, float left, float right, float top, float bot) {
          uint iy = ix>>1;
          return uint4(g_tex.CalculateLevelOfDetail(g_samp, float2(left, 0.5)) * (~ix&1) +
                       g_tex.CalculateLevelOfDetail(g_samp, float2(right, 0.5)) * (ix&1),
                       g_tex.Sample(g_samp, float2(left, 0.5)) * (~ix&1) +
                       g_tex.Sample(g_samp, float2(right, 0.5)) * (ix&1),
                       g_tex.CalculateLevelOfDetail(g_samp, float2(0.5, top)) * (~iy&1) +
                       g_tex.CalculateLevelOfDetail(g_samp, float2(0.5, bot)) * (iy&1),
                       g_tex.Sample(g_samp, float2(0.5, top)) * (~iy&1) +
                       g_tex.Sample(g_samp, float2(0.5, bot)) * (iy&1));
        }

        // To avoid conditionals, two samples are performed one for left one for right
        // They are step functioned on or off depending
        uint4 DerivTest(uint ix) {
          uint iy = ix>>1;
          return DerivTest(ix, ((ix^1)/64.0)*(ix&1), (ix/64.0)*(ix&1),
                               ((ix^2)/64.0)*(iy&1), (ix/64.0)*(iy&1));
        }

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        struct Payload {
          uint nothing;
        };

        [NumThreads(8, 8, 1)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          g_bufAmp[ix] = DerivTest(ix);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 1)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            verts[ix].position = g_Verts[ix];
            verts[ix].uv = g_UV[ix];
            if (ix % 3)
              tris[ix / 3] = uint3(ix, ix + 1, ix + 2);
            g_bufMesh[ix] = DerivTest(ix);
        }

        float4 PSMain(PSInput input) : SV_TARGET {
          int ix = int(input.uv.y * 8) * 8 + int(input.uv.x * 8);
          // Contort the linear index into quad order by rotating relevant middle bits
          ix = (ix&~0xE)|((ix&0x8)>>2)|((ix&0x6)<<1);
          g_bufMain[ix] = DerivTest(ix);
          return 1;
        }
        [NumThreads(8, 8, 1)]
        void CSMain(uint ix : SV_GroupIndex) {
          g_bufMain[ix] = DerivTest(ix);
        }

      ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="OOB" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), CBV(b0), DescriptorTable(SRV(t0,numDescriptors=2))</RootSignature>
    <Resource Name="CB0" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" TransitionTo="VERTEX_AND_CONSTANT_BUFFER">
      1.0f, 0.0f, 100.0f
    </Resource>
    <Resource Name="T0" Dimension="TEXTURE1D" InitialResourceState="COPY_DEST" Init="FromBytes" Format="R32_FLOAT">
      1.0f, 0.5f, 1.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f
    </Resource>
    <Resource Name='VBuffer' Dimension='BUFFER' Flags='ALLOW_UNORDERED_ACCESS' InitialResourceState='COPY_DEST' Init='FromBytes'>
      1.0f  1.0f 0, 1.0f -1.0f 0.0f, -1.0f -1.0f 0,
      -1.0f  1.0f 0, 1.0f  1.0f 0.0f, -1.0f -1.0f 0,
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue ResName="CB0" />
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name='ResHeap' Type='CBV_SRV_UAV'>
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName='POSITION' Format='R32G32B32_FLOAT' AlignedByteOffset='0' />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name='VS' Target='vs_6_0' EntryPoint='VSMain' Text="@PS" />
    <Shader Name='PS' Target='ps_6_0' EntryPoint='PSMain'>
      <![CDATA[
        // Resources that are not local scalars (and thus are bound):
        // - array in cbuffer
        // - array in local
        // - array in groupshared
        // - array in signature element
        // - resource access operations:
        //  - sampling
        //  - loading
        //  - storing
        //
        // In all cases, for HLSL, out-of-bound reads yield zero, and
        // out-of-bound writes are no-ops.
        cbuffer C {
          float c_arr;
          float zero_idx;
          float oob_idx;
        };
        Texture1D<float> g_t1d: register(t0);
        struct PSInput {
         float4 position : SV_POSITION;
        };
        PSInput VSMain(float4 position: POSITION) {
         PSInput result;
         result.position = position;
         return result;
        }
        float4 PSMain(PSInput input) : SV_TARGET {
         float x = input.position.x;
         float p0 = g_t1d.Load(zero_idx);
         float p1 = g_t1d.Load(oob_idx);
         float r = 0;
         // every color should be pure red (saturated red channel, zero'ed green channel).
         return float4(p0, p1, 0, 1);
        }
      ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name='Saturate' PS='PS' VS='VS'>
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), DescriptorTable(UAV(u0), CBV(b0))
    </RootSignature>
    <Resource Name='VBuffer' Dimension='BUFFER' Flags='ALLOW_UNORDERED_ACCESS' InitialResourceState='COPY_DEST' Init='FromBytes'>
      1.0f  1.0f 0, 1.0f -1.0f 0.0f, -1.0f -1.0f 0,
      -1.0f  1.0f 0, 1.0f  1.0f 0.0f, -1.0f -1.0f 0,
    </Resource>
    <Resource Name='CB0' Dimension='BUFFER' Width="256" InitialResourceState='COPY_DEST' Init='FromBytes'>
      -inf, -1.5f, -denorm, -0, 0, denorm, 1.5f, inf, nan
    </Resource>
    <Resource Name="U0" Dimension="BUFFER" Width="1280"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <DescriptorHeap Name='RtvHeap' NumDescriptors='1' Type='RTV'>
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name='ResHeap' Type='CBV_SRV_UAV'>
      <!-- Create a descriptor for a RWStructuredBuffer. The underlying resource must be of type DXGI_FORMAT_UNKNOWN. -->
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="320" StructureByteStride="4" />
      <Descriptor Name='CB0' Kind='CBV' ResName='CB0' />
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName='POSITION' Format='R32G32B32_FLOAT' AlignedByteOffset='0' />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name='VS' Target='vs_6_0' EntryPoint='VSMain' Text='@PS'/>
    <Shader Name='PS' Target='ps_6_0' EntryPoint='PSMain'>
      <![CDATA[
      struct c_floats_t {
       float c_neg_inf;
       float c_neg_f;
       float c_neg_denorm;
       float c_neg_zero;
       float c_zero;
       float c_denorm;
       float c_f;
       float c_inf;
       float c_nan;
      };
      RWStructuredBuffer<float> g_buf : register(u0);
      c_floats_t g_cf : register(b0);
      struct PSInput {
       float4 position : SV_POSITION;
       float4 color : COLOR;
      };
      PSInput VSMain(float4 position: POSITION) {
       PSInput result;
       result.position = position;
       result.color = 1;
       return result;
      }
      float4 PSMain(PSInput input) : SV_TARGET {
       uint x = (uint)input.position.x;
       float val;
       switch (x) {
       case 0:  val = saturate(g_cf.c_neg_inf); break;
       case 1:  val = saturate(g_cf.c_neg_f); break;
       case 2:  val = saturate(g_cf.c_neg_denorm); break;
       case 3:  val = saturate(g_cf.c_neg_zero); break;
       case 4:  val = saturate(g_cf.c_zero); break;
       case 5:  val = saturate(g_cf.c_denorm); break;
       case 6:  val = saturate(g_cf.c_f); break;
       case 7:  val = saturate(g_cf.c_inf); break;
       case 8:  val = saturate(g_cf.c_nan); break;
       default: val = x; break;
       }
       g_buf[x] = val;
       float r = 1;
       return float4(r, 0, 0, 1);
      }]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="UnaryFPOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SUnaryFPOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SUnaryFPOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="BinaryFPOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SBinaryFPOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SBinaryFPOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="UnaryIntOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SUnaryIntOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SUnaryIntOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="UnaryUintOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SUnaryUintOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SUnaryUintOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="BinaryIntOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SBinaryIntOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SBinaryIntOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="BinaryUintOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SBinaryUintOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SBinaryUintOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="TertiaryFPOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="STertiaryFPOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="STertiaryFPOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="TertiaryIntOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="STertiaryIntOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="STertiaryIntOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="TertiaryUintOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="STertiaryUintOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="STertiaryUintOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="DotOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDotOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDotOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Dot2AddHalfOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDot2AddHalfOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDot2AddHalfOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_4">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Dot4AddI8PackedOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDot4AddI8PackedOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDot4AddI8PackedOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_4">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Dot4AddU8PackedOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDot4AddU8PackedOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDot4AddU8PackedOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_4">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Msad4" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SMsad4" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SMsad4"/>
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="WaveIntrinsicsOp" CS="CS" DispatchX="1" DispatchY="1">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SWaveIntrinsicsOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SWaveIntrinsicsOp"/>
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Triangle" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</RootSignature>

    <Resource Name="VBuffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="FromBytes">
      { {   0.0f,  0.25f , 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } },
      { {  0.25f, -0.25f , 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } },
      { { -0.25f, -0.25f , 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />

    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="COLOR" Format="R32G32B32A32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>

    <Shader Name="VS" Target="vs_6_0">
      <![CDATA[
    struct PSInput {
      float4 position : SV_POSITION;
      float4 color : COLOR;
    };
    PSInput main(float4 position : POSITION, float4 color : COLOR) {
      PSInput result;
      float ratio = 320.0 / 200.0;
      result.position = position;
      result.position.y *= ratio;
      result.color = color;
      return result;
    }
    ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_0">
      <![CDATA[
    struct PSInput {
      float4 position : SV_POSITION;
      float4 color : COLOR;
    };
    float4 main(PSInput input) : SV_TARGET {
      return 1;
    }
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="TriangleHalf" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="FromBytes">
      { {   0.0h,  0.25h , 0.0h, 1.0h }, { 1.0h, 1.0h, 1.0h, 1.0h } },
      { {  0.25h, -0.25h , 0.0h, 1.0h }, { 1.0h, 1.0h, 1.0h, 1.0h } },
      { { -0.25h, -0.25h , 0.0h, 1.0h }, { 1.0h, 1.0h, 1.0h, 1.0h } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />

    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R16G16B16A16_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="COLOR" Format="R16G16B16A16_FLOAT" AlignedByteOffset="8" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>

    <Shader Name="VS" Target="vs_6_2" Arguments="/enable-16bit-types">
    <![CDATA[
    struct PSInput {
      half4 position : SV_POSITION;
      half4 color : COLOR;
    };
    PSInput main(half4 position : POSITION, half4 color : COLOR) {
      PSInput result;
      float ratio = 320.0 / 200.0;
      result.position = position;
      result.position.y *= ratio;
      result.color = color;
      return result;
    }
    ]]>
    </Shader>

    <Shader Name="PS" Target="ps_6_2" Arguments="/enable-16bit-types">
    <![CDATA[
    struct PSInput {
      half4 position : SV_POSITION;
      half4 color : COLOR;
    };
    half4 main(PSInput input) : SV_TARGET {
      return input.color;
    }
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="CBufferTestHalf" PS="PS" VS="VS" TopologyType="TRIANGLE">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), CBV(b0), DescriptorTable(SRV(t0,numDescriptors=2))</RootSignature>
    <Resource Name="CB0" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="ByName" TransitionTo="VERTEX_AND_CONSTANT_BUFFER">
      1.25h, 1.75h, 1.25h, 1.875h
    </Resource>
    <Resource Name='VBuffer' Dimension='BUFFER' Flags='ALLOW_UNORDERED_ACCESS' InitialResourceState='COPY_DEST' Init='FromBytes'>
      1.0f  1.0f 0, 1.0f -1.0f 0.0f, -1.0f -1.0f 0,
      -1.0f  1.0f 0, 1.0f  1.0f 0.0f, -1.0f -1.0f 0,
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R16G16B16A16_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue ResName="CB0" />
    </RootValues>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName='POSITION' Format='R32G32B32_FLOAT' AlignedByteOffset='0' />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name='VS' Target='vs_6_2' EntryPoint='VSMain' Arguments='-enable-16bit-types' Text="@PS" />
    <Shader Name='PS' Target='ps_6_2' EntryPoint='PSMain' Arguments='-enable-16bit-types'>
      <![CDATA[
        cbuffer c_buf {
          half first;
          half second;
          half third;
          half fourth;
        };
        struct PSInput {
         float4 position : SV_POSITION;
        };
        PSInput VSMain(float4 position: POSITION) {
         PSInput result;
         result.position = position;
         return result;
        }
        half4 PSMain(PSInput input) : SV_TARGET {
         return half4(first, second, third, fourth);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Barycentrics" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="FromBytes" ReadBack="true">
        { {   0.0f,  1.0f , 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } },
        { {   1.0f, -1.0f , 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } },
        { {  -1.0f, -1.0f , 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } }
      </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="5120" Height="9600" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="COLOR" Format="R32G32B32A32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_1">
      <![CDATA[
      struct PSInput {
        float4 position : SV_POSITION;
        nointerpolation float4 color : COLOR;
      };
      PSInput main(float4 position : POSITION, float4 color : COLOR) {
        PSInput result;
        result.position = position;
        result.color = color;
        return result;
      }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_1">
      <![CDATA[
      struct PSInput {
        float4 position : SV_POSITION;
        nointerpolation float4 color : COLOR;
      };
      float4 main(PSInput input, float3 bary : SV_Barycentrics) : SV_Target {
        float4 vColor0 = GetAttributeAtVertex(input.color, 0);
        float4 vColor1 = GetAttributeAtVertex(input.color, 1);
        float4 vColor2 = GetAttributeAtVertex(input.color, 2);
        return bary.x * vColor0 + bary.y * vColor1 + bary.z * vColor2;
      }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="ComputeRawBufferLdSt32Bit" CS="CS">
    <RootSignature>RootFlags(0), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="10" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="40" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="30" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="120" />
    </DescriptorHeap>
    <Shader Name="CS" Target="cs_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>>
  
  <ShaderOp Name="ComputeRawBufferLdSt64Bit" CS="CS">
    <RootSignature>RootFlags(0), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="20" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="80" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="60" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="240" />
    </DescriptorHeap>
    <Shader Name="CS" Target="cs_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>>

  <ShaderOp Name="ComputeRawBufferLdSt16Bit" CS="CS">
    <RootSignature>RootFlags(0), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="5" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="20" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="15" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="60" />
    </DescriptorHeap>
    <Shader Name="CS" Target="cs_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>>

  <ShaderOp Name="GraphicsRawBufferLdSt32Bit" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f,  0.0f } },
      { {  1.0f, 1.0f,  0.0f } },
      { { -1.0f, -1.0f, 0.0f } },

      { { -1.0f, -1.0f, 0.0f } },
      { {  1.0f,  1.0f, 0.0f } },
      { {  1.0f, -1.0f, 0.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="10" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="40" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="30" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="120" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_2">
      <![CDATA[
        struct PSInput {
          float4 pos : SV_POSITION;
        };
        PSInput main(float3 pos : POSITION) {
          PSInput r;
          r.pos = float4(pos, 1); 
          return r;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>
  
  <ShaderOp Name="GraphicsRawBufferLdSt64Bit" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f,  0.0f } },
      { {  1.0f, 1.0f,  0.0f } },
      { { -1.0f, -1.0f, 0.0f } },

      { { -1.0f, -1.0f, 0.0f } },
      { {  1.0f,  1.0f, 0.0f } },
      { {  1.0f, -1.0f, 0.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="20" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="80" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="60" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="240" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_2">
      <![CDATA[
        struct PSInput {
          float4 pos : SV_POSITION;
        };
        PSInput main(float3 pos : POSITION) {
          PSInput r;
          r.pos = float4(pos, 1); 
          return r;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="GraphicsRawBufferLdSt16Bit" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f,  0.0f } },
      { {  1.0f, 1.0f,  0.0f } },
      { { -1.0f, -1.0f, 0.0f } },

      { { -1.0f, -1.0f, 0.0f } },
      { {  1.0f,  1.0f, 0.0f } },
      { {  1.0f, -1.0f, 0.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="5" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="20" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="15" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="60" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_2">
      <![CDATA[
        struct PSInput {
          float4 pos : SV_POSITION;
        };
        PSInput main(float3 pos : POSITION) {
          PSInput r;
          r.pos = float4(pos, 1); 
          return r;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="WaveSizeTest" CS="CS">
      <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
      <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="512" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
      <RootValues>
          <RootValue Index="0" ResName="UAVBuffer0" />
      </RootValues>
      <Shader Name="CS" Target="cs_6_6">
          <![CDATA[// Shader source code will be set at runtime]]>
      </Shader>
  </ShaderOp>>

  <ShaderOp Name="PackUnpackOp" CS="CS" DispatchX="1" DispatchY="1">
    <RootSignature>RootFlags(0), UAV(u0), UAV(u1), UAV(u2)</RootSignature>
    <Resource Name="g_bufIn" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="false" />
    <Resource Name="g_bufOutPacked" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="g_bufOutPackedUnpacked" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="g_bufIn" />
      <RootValue Index="1" ResName="g_bufOutPacked" />
      <RootValue Index="2" ResName="g_bufOutPackedUnpacked" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Atomics" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(UAV(u0), UAV(u1), UAV(u2), UAV(u3), UAV(u4), UAV(u5), UAV(u6), UAV(u7), UAV(u8), UAV(u9), UAV(u10), UAV(u11)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" />
    <Resource Name="U0" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U1" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U2" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U3" Dimension="BUFFER" Width="544"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      {
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 99999999I, 99999999I, 0I, 0I, 99999999I, 99999999I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, -1I, -1I, 0I, 0I, -1I, -1I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0,
      }
    </Resource>
    <Resource Name="U4" Dimension="BUFFER" Width="107120"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U5" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U6" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U7" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U8" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U9" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U10" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U11" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name="U0" Kind="UAV" ResName="U0"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U1" Kind="UAV" ResName="U1"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U2" Kind="UAV" ResName="U2"
                  NumElements="1030" StructureByteStride="8" />
      <Descriptor Name="U3" Kind="UAV" ResName="U3"
                  NumElements="8" StructureByteStride="68" />
      <Descriptor Name="U4" Kind="UAV" ResName="U4"
                  NumElements="1030" StructureByteStride="68" />
      <Descriptor Name="U5" Kind="UAV" ResName="U5"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U6" Kind="UAV" ResName="U6"
                  NumElements="1030" StructureByteStride="8" />
      <Descriptor Name="U7" Kind="UAV" ResName="U7"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U8" Kind="UAV" ResName="U8"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U9" Kind="UAV" ResName="U9"
                  NumElements="1030" StructureByteStride="8" />
      <Descriptor Name="U10" Kind="UAV" ResName="U10"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U11" Kind="UAV" ResName="U11"
                  NumElements="1030" StructureByteStride="8" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="CSTY64" Target="cs_6_6" EntryPoint="CSMainTyped64" Text="@CS"/>
    <Shader Name="CSSH64" Target="cs_6_6" EntryPoint="CSMainShared64" Text="@CS"/>
    <Shader Name="CS64" Target="cs_6_6" EntryPoint="CSMain64" Text="@CS"/>
    <Shader Name="PS64" Target="ps_6_6" EntryPoint="PSMain64" Text="@CS"/>
    <Shader Name="AS64" Target="as_6_6" EntryPoint="ASMain64" Text="@CS"/>
    <Shader Name="MS64" Target="ms_6_6" EntryPoint="MSMain64" Text="@CS"/>
    <Shader Name="VS64" Target="vs_6_6" EntryPoint="VSMain64" Text="@CS"/>
    <Shader Name="AS"   Target="as_6_5" EntryPoint="ASMain"   Text="@CS"/>
    <Shader Name="MS"   Target="ms_6_5" EntryPoint="MSMain"   Text="@CS"/>
    <Shader Name="VS"   Target="vs_6_0" EntryPoint="VSMain"   Text="@CS"/>
    <Shader Name="PS"   Target="ps_6_0" EntryPoint="PSMain"   Text="@CS"/>
    <Shader Name="CS"   Target="cs_6_0" EntryPoint="CSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        struct AtomicStuff {
          float2 prepad[3];
          uint uintEl[4];
          int4  sintEl;
          struct useless {
            uint3 unused;
          } postpad;
        };
        struct Atomic64Stuff {
          float2 prepad[3];
          uint64_t uintEl[2];
          int64_t2  sintEl;
          struct useless {
            uint3 unused;
          } postpad;
        };
        RWBuffer<uint> g_uintBuf : register(u0);
        RWBuffer<int> g_sintBuf : register(u1);
        RWBuffer<int> g_xchgBuf : register(u2);

        RWStructuredBuffer<AtomicStuff> g_structBuf : register(u3);
        RWStructuredBuffer<AtomicStuff> g_strXchgBuf : register(u4);

        RWByteAddressBuffer g_rawBuf : register(u5);
        RWByteAddressBuffer g_rawXchgBuf : register(u6);

        RWTexture1D<uint> g_utexBuf : register(u7);
        RWTexture1D<int> g_stexBuf : register(u8);
        RWTexture1D<int> g_xtexBuf : register(u9);

        RWBuffer<uint> g_shareBuf : register(u10);
        RWBuffer<uint> g_shareXchgBuf : register(u11);

        groupshared uint g_uintShare[12];
        groupshared int g_sintShare[6];
        groupshared uint g_xchgShare[2048];

        RWBuffer<uint64_t> g_uint64Buf : register(u0);
        RWBuffer<int> g_sint64Buf : register(u1);
        RWBuffer<int64_t> g_xchg64Buf : register(u2);

        RWStructuredBuffer<Atomic64Stuff> g_struct64Buf : register(u3);
        RWStructuredBuffer<Atomic64Stuff> g_strXchg64Buf : register(u4);

        RWByteAddressBuffer g_raw64Buf : register(u5);
        RWByteAddressBuffer g_rawXchg64Buf : register(u6);

        RWTexture1D<uint64_t> g_utex64Buf : register(u7);
        RWTexture1D<int64_t> g_stex64Buf : register(u8);
        RWTexture1D<int64_t> g_xtex64Buf : register(u9);

        RWBuffer<uint64_t> g_share64Buf : register(u10);
        RWBuffer<uint64_t> g_shareXchg64Buf : register(u11);

        groupshared uint64_t g_uint64Share[6];
        groupshared int64_t g_sint64Share[3];
        groupshared uint64_t g_xchg64Share[1024];

        #define VEC_CALL(op, uav, ix, val) op(uav[ix*stride], val);

        #define USTRUCT_CALL(op, uav, ix, val) op(uav[ix].uintEl[stride], val);
        #define SSTRUCT_CALL(op, uav, ix, val) op(uav[ix].sintEl.z, val);
        #define SSTRUCT64_CALL(op, uav, ix, val) op(uav[ix].sintEl.y, val);

        #define URAW_CALL(op, uav, ix, val) uav.op(4*ix*stride, val);
        #define SRAW_CALL(op, uav, ix, val) uav.op(4*(5+ix)*stride, val); // signed at end. raw buffers don't need separate buffers

        #define OP_TEST(ucall, scall, uuav, suav) \
          ucall(InterlockedAdd, uuav, 0, ix); \
          scall(InterlockedMin, suav, 1, sminMaxVal); \
          scall(InterlockedMax, suav, 2, sminMaxVal); \
          ucall(InterlockedMin, uuav, 1, uminMaxVal); \
          ucall(InterlockedMax, uuav, 2, uminMaxVal); \
          ucall(InterlockedAnd, uuav, 3, ~value); \
          ucall(InterlockedOr,  uuav, 4, value); \
          ucall(InterlockedXor, uuav, 5, xorVal);

        #define VEC_CALL3(op, uav, ix, cmp, val) op(uav[(ix)*stride], cmp, val)
        #define VEC_CALL4(op, uav, ix, cmp, val, o) op(uav[(ix)*stride], cmp, val, o)

        #define STRUCT_CALL3(op, uav, ix, cmp, val) op(uav[ix].uintEl[stride], cmp, val)
        #define STRUCT_CALL4(op, uav, ix, cmp, val, o) op(uav[ix].uintEl[stride], cmp, val, o)

        #define RAW_CALL3(op, uav, ix, cmp, val) uav.op(4*(ix)*stride, cmp, val)
        #define RAW_CALL4(op, uav, ix, cmp, val, o) uav.op(4*(ix)*stride, cmp, val, o)

        // The first of four to match gets the first and then the winner performs the last two exchanges
        #define XCHG_TEST(call3, call4, uav) \
          call3(InterlockedCompareStore,    uav, ix >> 2, 0,           xchgVal - 2); \
          call4(InterlockedCompareExchange, uav, ix >> 2, xchgVal - 2, xchgVal - 1, output); \
          if (output == xchgVal - 2) { call3(InterlockedExchange, uav, ix >> 2, xchgVal, output);}

        void AtomicTest(uint ix, uint bitSize) {
          uint stride = 2;
          uint value = (ix) | ((ix) << (bitSize/2));
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1 << (ix%(bitSize-1));
          // make higher bits differ while lower bits match
          uint xchgVal = (ix << (bitSize/2)) | (ix & ~3);
          uint output = 0;

          OP_TEST(USTRUCT_CALL, SSTRUCT_CALL, g_structBuf, g_structBuf)
          XCHG_TEST(STRUCT_CALL3, STRUCT_CALL4, g_strXchgBuf)

          OP_TEST(URAW_CALL, SRAW_CALL, g_rawBuf, g_rawBuf)
          XCHG_TEST(RAW_CALL3, RAW_CALL4, g_rawXchgBuf)

          OP_TEST(VEC_CALL, VEC_CALL, g_uintBuf, g_sintBuf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgBuf)

          OP_TEST(VEC_CALL, VEC_CALL, g_utexBuf, g_stexBuf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xtexBuf)
        }

        void AtomicRaw64Test(uint ix, uint bitSize) {
          uint stride = 1;
          uint value = (ix) | ((ix) << (bitSize/2));
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1 << (ix%(bitSize-1));
          // make higher bits differ while lower bits match
          uint xchgVal = (ix << (bitSize/2)) | (ix & ~3);
          uint output = 0;

          OP_TEST(USTRUCT_CALL, SSTRUCT64_CALL, g_struct64Buf, g_struct64Buf)
          XCHG_TEST(STRUCT_CALL3, STRUCT_CALL4, g_strXchg64Buf)

          // ByteAddressBuffer for 64-bit values are a special case. inlined here
          URAW_CALL(InterlockedAdd64, g_raw64Buf, 0, ix);
          SRAW_CALL(InterlockedMin64, g_raw64Buf, 1, sminMaxVal);
          SRAW_CALL(InterlockedMax64, g_raw64Buf, 2, sminMaxVal);
          URAW_CALL(InterlockedMin64, g_raw64Buf, 1, uminMaxVal);
          URAW_CALL(InterlockedMax64, g_raw64Buf, 2, uminMaxVal);
          URAW_CALL(InterlockedAnd64, g_raw64Buf, 3, ~value);
          URAW_CALL(InterlockedOr64,  g_raw64Buf, 4, value);
          URAW_CALL(InterlockedXor64, g_raw64Buf, 5, xorVal);

          RAW_CALL3(InterlockedCompareStore64,    g_rawXchg64Buf, ix >> 2, 0,           xchgVal - 2);
          RAW_CALL4(InterlockedCompareExchange64, g_rawXchg64Buf, ix >> 2, xchgVal - 2, xchgVal - 1, output);
          if (output == xchgVal - 2) { RAW_CALL3(InterlockedExchange64, g_rawXchg64Buf, ix >> 2, xchgVal, output);}
        }

        void AtomicTyped64Test(uint ix, uint bitSize) {
          uint stride = 1;
          uint value = (ix) | ((ix) << (bitSize/2));
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1 << (ix%(bitSize-1));
          // make higher bits differ while lower bits match
          uint xchgVal = (ix << (bitSize/2)) | (ix & ~3);
          uint output = 0;

          OP_TEST(VEC_CALL, VEC_CALL, g_uint64Buf, g_sint64Buf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchg64Buf)

          OP_TEST(VEC_CALL, VEC_CALL, g_utex64Buf, g_stex64Buf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xtex64Buf)
        }

        void AtomicGroupSharedTest(uint ix, uint bitSize) {
          uint stride = 2;
          uint value = (ix) | ((ix) << 16);
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1 << (ix%(bitSize-1));
          uint xchgVal = (ix << 16) | (ix & ~3);
          uint output = 0;

          InterlockedCompareStore(g_uintShare[stride], 0, 99999999);
          InterlockedCompareStore(g_uintShare[3*stride], 0, -1);
          InterlockedCompareStore(g_sintShare[stride], 0, 99999999);

          OP_TEST(VEC_CALL, VEC_CALL, g_uintShare, g_sintShare)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgShare)

          GroupMemoryBarrierWithGroupSync();

          for (int i = 0; i < 6*stride; i++)
            g_shareBuf[i] = g_uintShare[i];
          g_shareBuf[6*stride] = g_sintShare[stride];
          g_shareBuf[7*stride] = g_sintShare[2*stride];

          g_shareXchgBuf[(ix>>2)*stride] = g_xchgShare[(ix>>2)*stride];
        }

        void AtomicGroupShared64Test(uint ix, uint bitSize) {
          uint stride = 2;
          uint value = (ix) | ((ix) << 16);
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1 << (ix%(bitSize-1));
          uint xchgVal = (ix << 16) | (ix & ~3);
          uint output = 0;

          InterlockedCompareStore(g_uint64Share[1], 0, 99999999);
          InterlockedCompareStore(g_uint64Share[3], 0, -1);
          InterlockedCompareStore(g_sint64Share[1], 0, 99999999);

          OP_TEST(VEC_CALL, VEC_CALL, g_uint64Share, g_sint64Share)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchg64Share)

          GroupMemoryBarrierWithGroupSync();

          for (int i = 0; i < 6*stride; i++)
            g_share64Buf[i] = g_uint64Share[i];
          g_share64Buf[6*stride] = g_sint64Share[1*stride];
          g_share64Buf[7*stride] = g_sint64Share[2*stride];

          g_shareXchg64Buf[(ix>>2)*stride] = g_xchg64Share[(ix>>2)*stride];

        }

        struct Payload {
          uint nothing;
        };

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        [NumThreads(8, 8, 2)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          payload.nothing = 0;
          AtomicTest(64*64 + 8*8 + ix, 32);
          AtomicGroupSharedTest(64*64 + 8*8 + ix, 32);
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            verts[ix].position = g_Verts[ix];
            verts[ix].uv = g_UV[ix];
            if (ix % 3)
              tris[ix / 3] = uint3(ix, ix + 1, ix + 2);
            AtomicTest(64*64 + ix, 32);
            AtomicGroupSharedTest(64*64 + ix, 32);
        }

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicTest(64*64 + ix, 32);
          return result;
        }

        float4 PSMain(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicTest(ix, 32);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMain(uint ix : SV_GroupIndex) {
          AtomicTest(ix, 32);
          AtomicGroupSharedTest(ix, 32);
        }

        [NumThreads(8, 8, 2)]
        void ASMain64(uint ix : SV_GroupIndex) {
          Payload payload;
          payload.nothing = 0;
          AtomicRaw64Test(64*64 + 8*8 + ix, 64);
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMain64(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            verts[ix].position = g_Verts[ix];
            verts[ix].uv = g_UV[ix];
            if (ix % 3)
              tris[ix / 3] = uint3(ix, ix + 1, ix + 2);
            AtomicRaw64Test(64*64 + ix, 64);
        }

        PSInput VSMain64(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicRaw64Test(64*64 + ix, 64);
          return result;
        }

        float4 PSMain64(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicRaw64Test(ix, 64);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMain64(uint ix : SV_GroupIndex) {
          AtomicRaw64Test(ix, 64);
        }

        [NumThreads(32, 32, 1)]
        void CSMainTyped64(uint ix : SV_GroupIndex) {
          AtomicTyped64Test(ix, 64);
        }

        [NumThreads(32, 32, 1)]
        void CSMainShared64(uint ix : SV_GroupIndex) {
          AtomicGroupShared64Test(ix, 64);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="FloatAtomics" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(UAV(u0), UAV(u1), UAV(u2), UAV(u3), UAV(u4), UAV(u5), UAV(u6), UAV(u7), UAV(u8), UAV(u9), UAV(u10), UAV(u11)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" />
    <Resource Name="U0" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="107120"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U3" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U4" Dimension="BUFFER" Width="8240"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name="U0" Kind="UAV" ResName="U0"
                  NumElements="1030" StructureByteStride="8" />
      <Descriptor Name="U1" Kind="UAV" ResName="U1"
                  NumElements="1030" StructureByteStride="68" />
      <Descriptor Name="U2" Kind="UAV" ResName="U2"
                  NumElements="1030" StructureByteStride="8" />
      <Descriptor Name="U3" Kind="UAV" ResName="U3"
                  NumElements="1030" StructureByteStride="8" />
      <Descriptor Name="U4" Kind="UAV" ResName="U4"
                  NumElements="1030" StructureByteStride="8" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="AS"   Target="as_6_5" EntryPoint="ASMain"   Text="@CS"/>
    <Shader Name="MS"   Target="ms_6_5" EntryPoint="MSMain"   Text="@CS"/>
    <Shader Name="VS"   Target="vs_6_0" EntryPoint="VSMain"   Text="@CS"/>
    <Shader Name="PS"   Target="ps_6_0" EntryPoint="PSMain"   Text="@CS"/>
    <Shader Name="CS"   Target="cs_6_0" EntryPoint="CSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        struct AtomicStuff {
          float2 prepad[3];
          float fltEl[2];
          struct useless {
            uint3 unused;
          } postpad;
        };

        RWBuffer<float> g_xchgBuf : register(u0);
        RWStructuredBuffer<AtomicStuff> g_strXchgBuf : register(u1);
        RWByteAddressBuffer g_rawXchgBuf : register(u2);
        RWTexture1D<float> g_xtexBuf : register(u3);
        RWBuffer<float> g_shareXchgBuf : register(u4);

        groupshared float g_xchgShare[1024];

        #define VEC_CALL3(op, uav, ix, cmp, val) op(uav[(ix)], cmp, val)
        #define VEC_CALL4(op, uav, ix, cmp, val, o) op(uav[(ix)], cmp, val, o)

        #define STRUCT_CALL3(op, uav, ix, cmp, val) op(uav[ix].fltEl[1], cmp, val)
        #define STRUCT_CALL4(op, uav, ix, cmp, val, o) op(uav[ix].fltEl[1], cmp, val, o)

        #define RAW_CALL3(op, uav, ix, cmp, val) uav.op(4*(ix), cmp, val)
        #define RAW_CALL4(op, uav, ix, cmp, val, o) uav.op(4*(ix), cmp, val, o)

        // The first of four to match gets the first and then the winner performs the last two exchanges
        #define XCHG_TEST(call3, call4, uav) \
          call3(InterlockedCompareStoreFloatBitwise,    uav, ix >> 2, 0,           xchgVal - 2); \
          call4(InterlockedCompareExchangeFloatBitwise, uav, ix >> 2, xchgVal - 2, xchgVal - 1, output); \
          if (output == xchgVal - 2) { call3(InterlockedExchange, uav, ix >> 2, xchgVal, output);}

        void AtomicTest(uint ix) {
          float xchgVal = ix & ~3;
          float output = 0;

          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgBuf)
          XCHG_TEST(STRUCT_CALL3, STRUCT_CALL4, g_strXchgBuf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xtexBuf)

          // Special case for ByteAddressBuffers
          RAW_CALL3(InterlockedCompareStoreFloatBitwise,    g_rawXchgBuf, ix >> 2, 0,           xchgVal - 2);
          RAW_CALL4(InterlockedCompareExchangeFloatBitwise, g_rawXchgBuf, ix >> 2, xchgVal - 2, xchgVal - 1, output);
          if (output == xchgVal - 2) { RAW_CALL3(InterlockedExchangeFloat, g_rawXchgBuf, ix >> 2, xchgVal, output);}

          // Check NaN corner case
          InterlockedCompareExchangeFloatBitwise(g_xchgBuf[0], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_xchgBuf[0], sqrt(-1), 0.123);

          InterlockedCompareExchangeFloatBitwise(g_strXchgBuf[0].fltEl[1], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_strXchgBuf[0].fltEl[1], sqrt(-1), 0.123);

          g_rawXchgBuf.InterlockedCompareExchangeFloatBitwise(0, 0, sqrt(-1), output);
          if (output == 0.0) g_rawXchgBuf.InterlockedCompareStoreFloatBitwise(0, sqrt(-1), 0.123);

          InterlockedCompareExchangeFloatBitwise(g_xtexBuf[0], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_xtexBuf[0], sqrt(-1), 0.123);

        }

        void AtomicGroupSharedTest(uint ix) {
          float xchgVal = ix & ~3;
          float output = 0;

          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgShare)

          InterlockedCompareExchangeFloatBitwise(g_xchgShare[0], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_xchgShare[0], sqrt(-1), 0.123);

          GroupMemoryBarrierWithGroupSync();

          g_shareXchgBuf[ix>>2] = g_xchgShare[ix>>2];
        }

        struct Payload {
          uint nothing;
        };

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        [NumThreads(8, 8, 2)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          payload.nothing = 0;
          AtomicTest(ix);
          AtomicGroupSharedTest(ix);
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            verts[ix].position = g_Verts[ix];
            verts[ix].uv = g_UV[ix];
            if (ix % 3)
              tris[ix / 3] = uint3(ix, ix + 1, ix + 2);
            AtomicTest(ix);
            AtomicGroupSharedTest(ix);
        }

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicTest(64*64 + ix);
          return result;
        }

        float4 PSMain(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicTest(ix);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMain(uint ix : SV_GroupIndex) {
          AtomicTest(ix);
          AtomicGroupSharedTest(ix);
        }
      ]]>
    </Shader>
  </ShaderOp>

    <!--
  TODO: Dynamically index into tables
  -->
</ShaderOpSet>
