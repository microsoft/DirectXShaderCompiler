<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<ShaderOpSet xmlns="http://schemas.microsoft.com/test/ShaderOp">
  <ShaderOp Name="DerivFine" PS="PS" VS="VS" TopologyType="TRIANGLE">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), DescriptorTable(SRV(t0,numDescriptors=1))</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="T0" Dimension="Texture2D" Width="4" Height="4" InitialResourceState="COPY_DEST" Init="FromBytes" Format="R32_FLOAT">
      {.125f, .25f, .5f, 1.0f},
      {2.0f, 4.0f, 16.0f, 32.0f},
      {32.0f, 64.0f, 128.0f, 256.0f},
      {256.0f, 512.0f, 1024.0f, 2048.0f}
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_0">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        PSInput main(float3 position : POSITION, float2 uv : TEXCOORD) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          return result;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_0">
      <![CDATA[
      struct PSInput {
        float4 position : SV_POSITION;
        float2 uv : TEXCOORD;
      };

      Texture2D<float> g_tex : register(t0);

      float4 main(PSInput input) : SV_TARGET {
        int3 offset = int3((input.uv * 64.0) % 4, 0);
        float val = g_tex.Load(offset);
        return float4(ddx_fine(val), ddy_fine(val), ddx_coarse(val), ddy_coarse(val));
      }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="WriteFloat4" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>

    <Resource Name="Buffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="Zero" ReadBack="true" TransitionTo="UNORDERED_ACCESS" />

    <RootValues>
      <RootValue Index="0" ResName="Buffer" />
    </RootValues>

    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    RWStructuredBuffer<float4> g_buf : register(u0);
    [numthreads(8,8,1)]
    void main(uint GI : SV_GroupIndex) {
      g_buf[GI] = GI;
    };
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Derivatives" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(SRV(t0,numDescriptors=1), UAV(u0), UAV(u1), UAV(u2)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="T0" Dimension="Texture2D" Width="4" Height="4" InitialResourceState="COPY_DEST" Init="FromBytes" Format="R32_FLOAT">
      {.125f, .25f, .5f, 1.0f},
      {2.0f, 4.0f, 16.0f, 32.0f},
      {32.0f, 64.0f, 128.0f, 256.0f},
      {256.0f, 512.0f, 1024.0f, 2048.0f}
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="32" Height="32" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <Resource Name="U0" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U1' Kind='UAV' ResName='U1'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U2' Kind='UAV' ResName='U2'
                  NumElements="1024" StructureByteStride="16" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="CS" Target="cs_6_6" EntryPoint="CSMain" Text="@PS"/>
    <Shader Name="AS" Target="as_6_6" EntryPoint="ASMain" Text="@PS"/>
    <Shader Name="MS" Target="ms_6_6" EntryPoint="MSMain" Text="@PS"/>
    <Shader Name="VS" Target="vs_6_0" EntryPoint="VSMain" Text="@PS"/>
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        Texture2D<float> g_tex : register(t0);
        RWStructuredBuffer<float4> g_bufMain : register(u0);
        RWStructuredBuffer<float4> g_bufMesh : register(u1);
        RWStructuredBuffer<float4> g_bufAmp : register(u2);

        float4 DerivTest(int2 uv) {
          int3 offset = int3(uv%4, 0);
          float val = g_tex.Load(offset);
          return float4(ddx_fine(val), ddy_fine(val), ddx_coarse(val), ddy_coarse(val));
        }

        // Map group index to 4x4 UV texcoord block
        int2 ConvertGroupIdx(uint groupIdx) {
          return int2(((groupIdx&0x4)>>1) + (groupIdx&01), ((groupIdx&0x8)>>2) + ((groupIdx&02)>>1));
        }

        // Convert group index into uv texcoords and return derivatives test result
        float4 DerivTest(uint groupIdx) {
          return DerivTest(ConvertGroupIdx(groupIdx));
        }

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          return result;
        }

        struct Payload {
          uint nothing;
        };

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          g_bufAmp[ix] = DerivTest(ix);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);
            g_bufMesh[ix] = DerivTest(ix);
        }
        float4 PSMain(PSInput input) : SV_TARGET {
          // Convert from texcoords into a groupIndex equivalent
          int width = DISPATCHX;
          int height = DISPATCHY;
          int2 uv = int2(input.uv.x*width, input.uv.y*height);
          uint ix = ((uv.y/4)*(width/4))*16 + (uv.x/4)*16 + (((uv.x & 0x2) << 1) | (uv.x & 0x1) | ((uv.y & 0x2) << 2) | ((uv.y & 0x1) << 1));

          float4 res = DerivTest(ix);
          g_bufMain[ix] = res;
          return res;
        }

        [NumThreads(DISPATCHX, DISPATCHY, DISPATCHZ)]
        void CSMain(uint ix : SV_GroupIndex) {
          g_bufMain[ix] = DerivTest(ix);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="QuadRead" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(UAV(u0), UAV(u1), UAV(u2))
    </RootSignature>
    <Resource Name="U0" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U1' Kind='UAV' ResName='U1'
                  NumElements="1024" StructureByteStride="16" />
      <Descriptor Name='U2' Kind='UAV' ResName='U2'
                  NumElements="1024" StructureByteStride="16" />
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <Shader Name="CS" Target="cs_6_0" EntryPoint="CSMain" Text="@PS"/>
    <Shader Name="AS" Target="as_6_6" EntryPoint="ASMain" Text="@PS"/>
    <Shader Name="MS" Target="ms_6_6" EntryPoint="MSMain" Text="@PS"/>
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
        };
        RWStructuredBuffer<int4> g_bufMain : register(u0);
        RWStructuredBuffer<int4> g_bufMesh : register(u1);
        RWStructuredBuffer<int4> g_bufAmp : register(u2);

        uint4 QuadReadTest(uint ix) {
          return int4(QuadReadLaneAt(ix, ix & 0x3), QuadReadAcrossX(ix),
                      QuadReadAcrossY(ix), QuadReadAcrossDiagonal(ix));
        }

        struct Payload {
          uint nothing;
        };

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        void ASMain(uint ix : SV_GroupIndex) {
          Payload payload;
          g_bufAmp[ix] = QuadReadTest(ix);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        [NumThreads(MESHDISPATCHX, MESHDISPATCHY, MESHDISPATCHZ)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);
            g_bufMesh[ix] = QuadReadTest(ix);
        }

        void PSMain(PSInput input) {
          return;
        }

        [NumThreads(DISPATCHX, DISPATCHY, DISPATCHZ)]
        void CSMain(uint ix : SV_GroupIndex) {
          g_bufMain[ix] = QuadReadTest(ix);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="ComputeSample" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(SRV(t0,numDescriptors=1), UAV(u0), UAV(u1), UAV(u2)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="T0" Dimension="Texture2D" Width="336" Height="336" MipLevels="7" InitialResourceState="COPY_DEST" Init="ByName" Format="R32_FLOAT" />
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="84" Height="4" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" />
    <Resource Name="U0" Dimension="BUFFER" Width="16384"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="2048"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="2048"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />

    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="336" StructureByteStride="16" />
      <Descriptor Name='U1' Kind='UAV' ResName='U1'
                  NumElements="128" StructureByteStride="16" />
      <Descriptor Name='U2' Kind='UAV' ResName='U2'
                  NumElements="128" StructureByteStride="16" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="CS" Target="cs_6_6" EntryPoint="CSMain1D" Text="@PS"/>
    <Shader Name="AS" Target="as_6_6" EntryPoint="ASMain1D" Text="@PS"/>
    <Shader Name="MS" Target="ms_6_6" EntryPoint="MSMain1D" Text="@PS"/>
    <Shader Name="CS2" Target="cs_6_6" EntryPoint="CSMain2D" Text="@PS"/>
    <Shader Name="AS2" Target="as_6_6" EntryPoint="ASMain2D" Text="@PS"/>
    <Shader Name="MS2" Target="ms_6_6" EntryPoint="MSMain2D" Text="@PS"/>
    <Shader Name="VS" Target="vs_6_0" EntryPoint="VSMain" Text="@PS"/>
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };

        Texture2D<float> g_tex : register(t0);
        RWStructuredBuffer<uint4> g_bufMain : register(u0);
        RWStructuredBuffer<uint4> g_bufMesh : register(u1);
        RWStructuredBuffer<uint4> g_bufAmp : register(u2);

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          return result;
        }

        SamplerState g_samp : register(s0);

        uint4 DerivTest(uint ix, uint iy, float left, float right, float top, float bot) {
          return uint4(g_tex.CalculateLevelOfDetail(g_samp, float2(left, 0.5)) * (~ix&1) +
                       g_tex.CalculateLevelOfDetail(g_samp, float2(right, 0.5)) * (ix&1),
                       g_tex.Sample(g_samp, float2(left, 0.5)) * (~ix&1) +
                       g_tex.Sample(g_samp, float2(right, 0.5)) * (ix&1),
                       g_tex.CalculateLevelOfDetail(g_samp, float2(0.5, top)) * (~iy&1) +
                       g_tex.CalculateLevelOfDetail(g_samp, float2(0.5, bot)) * (iy&1),
                       g_tex.Sample(g_samp, float2(0.5, top)) * (~iy&1) +
                       g_tex.Sample(g_samp, float2(0.5, bot)) * (iy&1));
        }

        // To avoid conditionals, two samples are performed one for left one for right
        // They are step functioned on or off depending
        uint4 DerivTest(uint ix, float threadCt) {
          uint iy = ix>>1;
          return DerivTest(ix, iy, ((ix^1)/threadCt)*(ix&1), (ix/threadCt)*(ix&1),
                                   ((ix^2)/threadCt)*(iy&1), (ix/threadCt)*(iy&1));
        }

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        struct Payload {
          uint nothing;
        };

        uint convert2Dto1D(uint x, uint y, uint width) {
          // Convert 2D coords to 1D for testing
          // All completed rows of quads
          uint prevRows = (y/2)*2*width;
          // All previous full quads on this quad row
          uint prevQuads = (x/2)*4;
          // index into current quad
          uint quadIx = (y&1)*2 + (x&1);
          return prevRows + prevQuads + quadIx;
        }

        [NumThreads(116, 1, 1)]
        void ASMain1D(uint ix : SV_GroupIndex) {
          Payload payload;
          g_bufAmp[ix] = DerivTest(ix, 116);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(42, 2, 1)]
        void ASMain2D(uint3 id : SV_GroupThreadID) {
          Payload payload;
          uint ix = convert2Dto1D(id.x, id.y, 42);
          g_bufAmp[ix] = DerivTest(ix, 42*2);
          payload.nothing = 0;
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(116, 1, 1)]
        [OutputTopology("triangle")]
        void MSMain1D(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);
            g_bufMesh[ix] = DerivTest(ix, 116);
        }

        [NumThreads(42, 2, 1)]
        [OutputTopology("triangle")]
        void MSMain2D(
          uint3 id : SV_GroupThreadID,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            uint ix = convert2Dto1D(id.x, id.y, 42);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);
            g_bufMesh[ix] = DerivTest(ix, 42*2);
        }

        float4 PSMain(PSInput input) : SV_TARGET {
          uint ix = convert2Dto1D(input.uv.x, input.uv.y, 84);
          g_bufMain[ix] = DerivTest(ix, 84*4*3);
          return 1;
        }
        [NumThreads(336, 1, 1)]
        void CSMain1D(uint ix : SV_GroupIndex) {
          g_bufMain[ix] = DerivTest(ix, 336);
        }

        [NumThreads(84, 4, 3)]
        void CSMain2D(uint3 id : SV_GroupThreadID) {
          uint ix = convert2Dto1D(id.x, id.y, 84);
          g_bufMain[ix] = DerivTest(ix, 84*4);
        }

      ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="OOB" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), CBV(b0), DescriptorTable(SRV(t0,numDescriptors=2))</RootSignature>
    <Resource Name="CB0" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" TransitionTo="VERTEX_AND_CONSTANT_BUFFER">
      1.0f, 0.0f, 100.0f
    </Resource>
    <Resource Name="T0" Dimension="TEXTURE1D" InitialResourceState="COPY_DEST" Init="FromBytes" Format="R32_FLOAT">
      1.0f, 0.5f, 1.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f
    </Resource>
    <Resource Name='VBuffer' Dimension='BUFFER' Flags='ALLOW_UNORDERED_ACCESS' InitialResourceState='COPY_DEST' Init='FromBytes'>
      1.0f  1.0f 0, 1.0f -1.0f 0.0f, -1.0f -1.0f 0,
      -1.0f  1.0f 0, 1.0f  1.0f 0.0f, -1.0f -1.0f 0,
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue ResName="CB0" />
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name='ResHeap' Type='CBV_SRV_UAV'>
      <Descriptor Name='T0' Kind='SRV' ResName='T0' />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName='POSITION' Format='R32G32B32_FLOAT' AlignedByteOffset='0' />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name='VS' Target='vs_6_0' EntryPoint='VSMain' Text="@PS" />
    <Shader Name='PS' Target='ps_6_0' EntryPoint='PSMain'>
      <![CDATA[
        // Resources that are not local scalars (and thus are bound):
        // - array in cbuffer
        // - array in local
        // - array in groupshared
        // - array in signature element
        // - resource access operations:
        //  - sampling
        //  - loading
        //  - storing
        //
        // In all cases, for HLSL, out-of-bound reads yield zero, and
        // out-of-bound writes are no-ops.
        cbuffer C {
          float c_arr;
          float zero_idx;
          float oob_idx;
        };
        Texture1D<float> g_t1d: register(t0);
        struct PSInput {
         float4 position : SV_POSITION;
        };
        PSInput VSMain(float4 position: POSITION) {
         PSInput result;
         result.position = position;
         return result;
        }
        float4 PSMain(PSInput input) : SV_TARGET {
         float x = input.position.x;
         float p0 = g_t1d.Load(zero_idx);
         float p1 = g_t1d.Load(oob_idx);
         float r = 0;
         // every color should be pure red (saturated red channel, zero'ed green channel).
         return float4(p0, p1, 0, 1);
        }
      ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name='Saturate' PS='PS' VS='VS'>
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), DescriptorTable(UAV(u0), CBV(b0))
    </RootSignature>
    <Resource Name='VBuffer' Dimension='BUFFER' Flags='ALLOW_UNORDERED_ACCESS' InitialResourceState='COPY_DEST' Init='FromBytes'>
      1.0f  1.0f 0, 1.0f -1.0f 0.0f, -1.0f -1.0f 0,
      -1.0f  1.0f 0, 1.0f  1.0f 0.0f, -1.0f -1.0f 0,
    </Resource>
    <Resource Name='CB0' Dimension='BUFFER' Width="256" InitialResourceState='COPY_DEST' Init='FromBytes'>
      -inf, -1.5f, -denorm, -0, 0, denorm, 1.5f, inf, nan
    </Resource>
    <Resource Name="U0" Dimension="BUFFER" Width="1280"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <DescriptorHeap Name='RtvHeap' NumDescriptors='1' Type='RTV'>
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name='ResHeap' Type='CBV_SRV_UAV'>
      <!-- Create a descriptor for a RWStructuredBuffer. The underlying resource must be of type DXGI_FORMAT_UNKNOWN. -->
      <Descriptor Name='U0' Kind='UAV' ResName='U0'
                  NumElements="320" StructureByteStride="4" />
      <Descriptor Name='CB0' Kind='CBV' ResName='CB0' />
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName='POSITION' Format='R32G32B32_FLOAT' AlignedByteOffset='0' />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name='VS' Target='vs_6_0' EntryPoint='VSMain' Text='@PS'/>
    <Shader Name='PS' Target='ps_6_0' EntryPoint='PSMain'>
      <![CDATA[
      struct c_floats_t {
       float c_neg_inf;
       float c_neg_f;
       float c_neg_denorm;
       float c_neg_zero;
       float c_zero;
       float c_denorm;
       float c_f;
       float c_inf;
       float c_nan;
      };
      RWStructuredBuffer<float> g_buf : register(u0);
      c_floats_t g_cf : register(b0);
      struct PSInput {
       float4 position : SV_POSITION;
       float4 color : COLOR;
      };
      PSInput VSMain(float4 position: POSITION) {
       PSInput result;
       result.position = position;
       result.color = 1;
       return result;
      }
      float4 PSMain(PSInput input) : SV_TARGET {
       uint x = (uint)input.position.x;
       float val;
       switch (x) {
       case 0:  val = saturate(g_cf.c_neg_inf); break;
       case 1:  val = saturate(g_cf.c_neg_f); break;
       case 2:  val = saturate(g_cf.c_neg_denorm); break;
       case 3:  val = saturate(g_cf.c_neg_zero); break;
       case 4:  val = saturate(g_cf.c_zero); break;
       case 5:  val = saturate(g_cf.c_denorm); break;
       case 6:  val = saturate(g_cf.c_f); break;
       case 7:  val = saturate(g_cf.c_inf); break;
       case 8:  val = saturate(g_cf.c_nan); break;
       default: val = x; break;
       }
       g_buf[x] = val;
       float r = 1;
       return float4(r, 0, 0, 1);
      }]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="UnaryFPOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SUnaryFPOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SUnaryFPOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="BinaryFPOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SBinaryFPOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SBinaryFPOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="UnaryIntOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SUnaryIntOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SUnaryIntOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="UnaryUintOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SUnaryUintOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SUnaryUintOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="BinaryIntOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SBinaryIntOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SBinaryIntOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="BinaryUintOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SBinaryUintOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SBinaryUintOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="TertiaryFPOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="STertiaryFPOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="STertiaryFPOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="TertiaryIntOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="STertiaryIntOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="STertiaryIntOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>
  <ShaderOp Name="TertiaryUintOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="STertiaryUintOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="STertiaryUintOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
    void main(uint GI : SV_GroupIndex) {};
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="DotOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDotOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDotOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Dot2AddHalfOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDot2AddHalfOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDot2AddHalfOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_4">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Dot4AddI8PackedOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDot4AddI8PackedOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDot4AddI8PackedOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_4">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Dot4AddU8PackedOp" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SDot4AddU8PackedOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SDot4AddU8PackedOp" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_4">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Msad4" CS="CS" DispatchX="8" DispatchY="8">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SMsad4" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SMsad4"/>
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="WaveIntrinsicsOp" CS="CS" DispatchX="1" DispatchY="1">
    <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
    <Resource Name="SWaveIntrinsicsOp" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SWaveIntrinsicsOp"/>
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Triangle" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</RootSignature>

    <Resource Name="VBuffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="FromBytes">
      { {   0.0f,  0.25f , 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } },
      { {  0.25f, -0.25f , 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } },
      { { -0.25f, -0.25f , 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />

    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="COLOR" Format="R32G32B32A32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>

    <Shader Name="VS" Target="vs_6_0">
      <![CDATA[
    struct PSInput {
      float4 position : SV_POSITION;
      float4 color : COLOR;
    };
    PSInput main(float4 position : POSITION, float4 color : COLOR) {
      PSInput result;
      float ratio = 320.0 / 200.0;
      result.position = position;
      result.position.y *= ratio;
      result.color = color;
      return result;
    }
    ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_0">
      <![CDATA[
    struct PSInput {
      float4 position : SV_POSITION;
      float4 color : COLOR;
    };
    float4 main(PSInput input) : SV_TARGET {
      return 1;
    }
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="TriangleHalf" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="FromBytes">
      { {   0.0h,  0.25h , 0.0h, 1.0h }, { 1.0h, 1.0h, 1.0h, 1.0h } },
      { {  0.25h, -0.25h , 0.0h, 1.0h }, { 1.0h, 1.0h, 1.0h, 1.0h } },
      { { -0.25h, -0.25h , 0.0h, 1.0h }, { 1.0h, 1.0h, 1.0h, 1.0h } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R8G8B8A8_UNORM" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />

    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R16G16B16A16_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="COLOR" Format="R16G16B16A16_FLOAT" AlignedByteOffset="8" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>

    <Shader Name="VS" Target="vs_6_2" Arguments="/enable-16bit-types">
    <![CDATA[
    struct PSInput {
      half4 position : SV_POSITION;
      half4 color : COLOR;
    };
    PSInput main(half4 position : POSITION, half4 color : COLOR) {
      PSInput result;
      float ratio = 320.0 / 200.0;
      result.position = position;
      result.position.y *= ratio;
      result.color = color;
      return result;
    }
    ]]>
    </Shader>

    <Shader Name="PS" Target="ps_6_2" Arguments="/enable-16bit-types">
    <![CDATA[
    struct PSInput {
      half4 position : SV_POSITION;
      half4 color : COLOR;
    };
    half4 main(PSInput input) : SV_TARGET {
      return input.color;
    }
    ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="CBufferTestHalf" PS="PS" VS="VS" TopologyType="TRIANGLE">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), CBV(b0), DescriptorTable(SRV(t0,numDescriptors=2))</RootSignature>
    <Resource Name="CB0" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="ByName" TransitionTo="VERTEX_AND_CONSTANT_BUFFER">
      1.25h, 1.75h, 1.25h, 1.875h
    </Resource>
    <Resource Name='VBuffer' Dimension='BUFFER' Flags='ALLOW_UNORDERED_ACCESS' InitialResourceState='COPY_DEST' Init='FromBytes'>
      1.0f  1.0f 0, 1.0f -1.0f 0.0f, -1.0f -1.0f 0,
      -1.0f  1.0f 0, 1.0f  1.0f 0.0f, -1.0f -1.0f 0,
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="320" Height="200" Format="R16G16B16A16_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue ResName="CB0" />
    </RootValues>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName='POSITION' Format='R32G32B32_FLOAT' AlignedByteOffset='0' />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name='VS' Target='vs_6_2' EntryPoint='VSMain' Arguments='-enable-16bit-types' Text="@PS" />
    <Shader Name='PS' Target='ps_6_2' EntryPoint='PSMain' Arguments='-enable-16bit-types'>
      <![CDATA[
        cbuffer c_buf {
          half first;
          half second;
          half third;
          half fourth;
        };
        struct PSInput {
         float4 position : SV_POSITION;
        };
        PSInput VSMain(float4 position: POSITION) {
         PSInput result;
         result.position = position;
         return result;
        }
        half4 PSMain(PSInput input) : SV_TARGET {
         return half4(first, second, third, fourth);
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="Barycentrics" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" Init="FromBytes" ReadBack="true">
        { {   0.0f,  1.0f , 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } },
        { {   1.0f, -1.0f , 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } },
        { {  -1.0f, -1.0f , 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } }
      </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="1280" Height="2400" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="COLOR" Format="R32G32B32A32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget" />
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_1">
      <![CDATA[
      struct PSInput {
        float4 position : SV_POSITION;
        nointerpolation float4 color : COLOR;
      };
      PSInput main(float4 position : POSITION, float4 color : COLOR) {
        PSInput result;
        result.position = position;
        result.color = color;
        return result;
      }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_1">
      <![CDATA[
      struct PSInput {
        float4 position : SV_POSITION;
        nointerpolation float4 color : COLOR;
      };
      float4 main(PSInput input, float3 bary : SV_Barycentrics) : SV_Target {
        float4 vColor0 = GetAttributeAtVertex(input.color, 0);
        float4 vColor1 = GetAttributeAtVertex(input.color, 1);
        float4 vColor2 = GetAttributeAtVertex(input.color, 2);
        return bary.x * vColor0 + bary.y * vColor1 + bary.z * vColor2;
      }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="ComputeRawBufferLdSt32Bit" CS="CS">
    <RootSignature>RootFlags(0), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="120" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="10" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="40" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="30" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="120" />
    </DescriptorHeap>
    <Shader Name="CS" Target="cs_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>>
  
  <ShaderOp Name="ComputeRawBufferLdSt64Bit" CS="CS">
    <RootSignature>RootFlags(0), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="240" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="20" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="80" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="60" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="240" />
    </DescriptorHeap>
    <Shader Name="CS" Target="cs_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>>

  <ShaderOp Name="ComputeRawBufferLdSt16Bit" CS="CS">
    <RootSignature>RootFlags(0), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="20" InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="5" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="20" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="15" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="60" />
    </DescriptorHeap>
    <Shader Name="CS" Target="cs_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>>

  <ShaderOp Name="GraphicsRawBufferLdSt32Bit" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="40"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f,  0.0f } },
      { {  1.0f, 1.0f,  0.0f } },
      { { -1.0f, -1.0f, 0.0f } },

      { { -1.0f, -1.0f, 0.0f } },
      { {  1.0f,  1.0f, 0.0f } },
      { {  1.0f, -1.0f, 0.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="10" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="40" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="30" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="120" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_2">
      <![CDATA[
        struct PSInput {
          float4 pos : SV_POSITION;
        };
        PSInput main(float3 pos : POSITION) {
          PSInput r;
          r.pos = float4(pos, 1); 
          return r;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>
  
  <ShaderOp Name="GraphicsRawBufferLdSt64Bit" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="80"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="240" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f,  0.0f } },
      { {  1.0f, 1.0f,  0.0f } },
      { { -1.0f, -1.0f, 0.0f } },

      { { -1.0f, -1.0f, 0.0f } },
      { {  1.0f,  1.0f, 0.0f } },
      { {  1.0f, -1.0f, 0.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="20" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="80" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="60" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="240" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_2">
      <![CDATA[
        struct PSInput {
          float4 pos : SV_POSITION;
        };
        PSInput main(float3 pos : POSITION) {
          PSInput r;
          r.pos = float4(pos, 1); 
          return r;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="GraphicsRawBufferLdSt16Bit" PS="PS" VS="VS">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), SRV(t0), SRV(t1), UAV(u0), UAV(u1), DescriptorTable(SRV(t2,numDescriptors=2), UAV(u2,numDescriptors=2))</RootSignature>
    <Resource Name="SRVBuffer0" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer1" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="SRVBuffer2" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" Format="R32_TYPELESS"/>
    <Resource Name="SRVBuffer3" Dimension="BUFFER" Width="20"  InitialResourceState="COPY_DEST" Init="ByName" />
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer1" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="UAVBuffer2" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="UAVBuffer3" Dimension="BUFFER" Width="60" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f,  0.0f } },
      { {  1.0f, 1.0f,  0.0f } },
      { { -1.0f, -1.0f, 0.0f } },

      { { -1.0f, -1.0f, 0.0f } },
      { {  1.0f,  1.0f, 0.0f } },
      { {  1.0f, -1.0f, 0.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="SRVBuffer0" />
      <RootValue Index="1" ResName="SRVBuffer1" />
      <RootValue Index="2" ResName="UAVBuffer0" />
      <RootValue Index="3" ResName="UAVBuffer1" />
      <RootValue Index="4" HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name='SRVBuffer2' Kind='SRV' ResName='SRVBuffer2' Flags='RAW' NumElements="5" Format="R32_TYPELESS" />
      <Descriptor Name='SRVBuffer3' Kind='SRV' ResName='SRVBuffer3' NumElements="1" StructureByteStride="20" />
      <Descriptor Name='UAVBuffer2' Kind='UAV' ResName='UAVBuffer2' Flags='RAW' NumElements="15" Format="R32_TYPELESS" />
      <Descriptor Name='UAVBuffer3' Kind='UAV' ResName='UAVBuffer3' NumElements="1" StructureByteStride="60" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_2">
      <![CDATA[
        struct PSInput {
          float4 pos : SV_POSITION;
        };
        PSInput main(float3 pos : POSITION) {
          PSInput r;
          r.pos = float4(pos, 1); 
          return r;
        }
      ]]>
    </Shader>
    <Shader Name="PS" Target="ps_6_2">
      <![CDATA[// Shader source code will be set at runtime]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="WaveSizeTest" CS="CS">
      <RootSignature>RootFlags(0), UAV(u0)</RootSignature>
      <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="512" InitialResourceState="COPY_DEST" Init="ByName" Flags="ALLOW_UNORDERED_ACCESS" TransitionTo="UNORDERED_ACCESS" ReadBack="true" Format="R32_TYPELESS" />
      <RootValues>
          <RootValue Index="0" ResName="UAVBuffer0" />
      </RootValues>
      <Shader Name="CS" Target="cs_6_6">
          <![CDATA[// Shader source code will be set at runtime]]>
      </Shader>
  </ShaderOp>>

  <ShaderOp Name="PackUnpackOp" CS="CS" DispatchX="1" DispatchY="1">
    <RootSignature>RootFlags(0), UAV(u0), UAV(u1), UAV(u2)</RootSignature>
    <Resource Name="g_bufIn" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="false" />
    <Resource Name="g_bufOutPacked" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <Resource Name="g_bufOutPackedUnpacked" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" />
    <RootValues>
      <RootValue Index="0" ResName="g_bufIn" />
      <RootValue Index="1" ResName="g_bufOutPacked" />
      <RootValue Index="2" ResName="g_bufOutPackedUnpacked" />
    </RootValues>
    <Shader Name="CS" Target="cs_6_0">
      <![CDATA[
      void main(uint GI : SV_GroupIndex) {};
      ]]>
    </Shader>
  </ShaderOp>

  <!-- For explanations of the atomics tests, see comments in and around VerifyAtomicResults in Executiontest.cpp -->
  <ShaderOp Name="Atomics" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(UAV(u0), UAV(u1), UAV(u2), UAV(u3), UAV(u4), UAV(u5), UAV(u6), UAV(u7), UAV(u8), UAV(u9), UAV(u10), UAV(u11), UAV(u12), UAV(u13), UAV(u14), UAV(u15), UAV(u16), UAV(u17)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" />
    <!-- Raw buffers -->
    <Resource Name="U0" Dimension="BUFFER" Width="576"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      {
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 99999999I, 99999999I, 0I, 0I, 99999999I, 99999999I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, -1I, -1I, 0I, 0I, -1I, -1I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, 0, 0, 0, 0,
      }
    </Resource>
    <Resource Name="U1" Dimension="BUFFER" Width="9216"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U3" Dimension="BUFFER" Width="1024"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <!-- 32-bit typed resources -->
    <Resource Name="U4" Dimension="BUFFER" Width="256" Format="R32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U5" Dimension="BUFFER" Width="256" Format="R32_SINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U6" Dimension="BUFFER" Width="1024" Format="R32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U7" Dimension="TEXTURE1D" Width="16" Format="R32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U8" Dimension="TEXTURE1D" Width="16" Format="R32_SINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U9" Dimension="TEXTURE1D" Width="128" Format="R32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <!-- groupshared output buffers -->
    <Resource Name="U10" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U11" Dimension="BUFFER" Width="1024"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <!-- 64-bit typed resources -->
    <Resource Name="U12" Dimension="BUFFER" Width="256" Format="R32G32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U13" Dimension="BUFFER" Width="256" Format="R32G32_SINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U14" Dimension="BUFFER" Width="1024" Format="R32G32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U15" Dimension="TEXTURE1D" Width="16" Format="R32G32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true" >
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U16" Dimension="TEXTURE1D" Width="16" Format="R32G32_SINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="FromBytes" ReadBack="true">
      { 0I, 0I, 99999999I, 99999999I, 0I, 0I, -1I, -1I, 0I, 0I, 0I, 0I, 42I, 42I, 42I, 42I }
    </Resource>
    <Resource Name="U17" Dimension="TEXTURE1D" Width="128" Format="R32G32_UINT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <!-- Raw buffers -->
      <Descriptor Name="U0" Kind="UAV" ResName="U0"
                  NumElements="8" StructureByteStride="72" />
      <Descriptor Name="U1" Kind="UAV" ResName="U1"
                  NumElements="128" StructureByteStride="72" />
      <Descriptor Name="U2" Kind="UAV" ResName="U2"
                  NumElements="16" StructureByteStride="8" />
      <Descriptor Name="U3" Kind="UAV" ResName="U3"
                  NumElements="128" StructureByteStride="8" />
      <!-- 32-bit typed resources -->
      <Descriptor Name="U4" Kind="UAV" ResName="U4" Dimension="BUFFER"
                  NumElements="16"  Format="R32_UINT" />
      <Descriptor Name="U5" Kind="UAV" ResName="U5" Dimension="BUFFER"
                  NumElements="16"  Format="R32_UINT" />
      <Descriptor Name="U6" Kind="UAV" ResName="U6" Dimension="BUFFER"
                  NumElements="128"  Format="R32_UINT" />
      <Descriptor Name="U7" Kind="UAV" ResName="U7" Dimension="TEXTURE1D"
                  NumElements="16"  Format="R32_UINT" />
      <Descriptor Name="U8" Kind="UAV" ResName="U8" Dimension="TEXTURE1D"
                  NumElements="16"  Format="R32_UINT" />
      <Descriptor Name="U9" Kind="UAV" ResName="U9" Dimension="TEXTURE1D"
                  NumElements="128"  Format="R32_UINT" />
      <!-- groupshared output buffers -->
      <Descriptor Name="U10" Kind="UAV" ResName="U10" Dimension="BUFFER"
                  NumElements="8" Format="R32G32_UINT" />
      <Descriptor Name="U11" Kind="UAV" ResName="U11" Dimension="BUFFER"
                  NumElements="64" Format="R32G32_UINT" />
      <!-- 64-bit typed resources -->
      <Descriptor Name="U12" Kind="UAV" ResName="U12" Dimension="BUFFER"
                  NumElements="16"  Format="R32G32_UINT" />
      <Descriptor Name="U13" Kind="UAV" ResName="U13" Dimension="BUFFER"
                  NumElements="16"  Format="R32G32_UINT" />
      <Descriptor Name="U14" Kind="UAV" ResName="U14" Dimension="BUFFER"
                  NumElements="128"  Format="R32G32_UINT" />
      <Descriptor Name="U15" Kind="UAV" ResName="U15" Dimension="TEXTURE1D"
                  NumElements="16"  Format="R32G32_UINT" />
      <Descriptor Name="U16" Kind="UAV" ResName="U16" Dimension="TEXTURE1D"
                  NumElements="16"  Format="R32G32_UINT" />
      <Descriptor Name="U17" Kind="UAV" ResName="U17" Dimension="TEXTURE1D"
                  NumElements="128"  Format="R32G32_UINT" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="PS64" Target="ps_6_6" EntryPoint="PSMain64" Text="@CS"/>
    <Shader Name="AS64" Target="as_6_6" EntryPoint="ASMain64" Text="@CS"/>
    <Shader Name="MS64" Target="ms_6_6" EntryPoint="MSMain64" Text="@CS"/>
    <Shader Name="VS64" Target="vs_6_6" EntryPoint="VSMain64" Text="@CS"/>
    <Shader Name="CS64" Target="cs_6_6" EntryPoint="CSMain64" Text="@CS"/>
    <Shader Name="PSTY64" Target="ps_6_6" EntryPoint="PSMainTyped64" Text="@CS"/>
    <Shader Name="ASTY64" Target="as_6_6" EntryPoint="ASMainTyped64" Text="@CS"/>
    <Shader Name="MSTY64" Target="ms_6_6" EntryPoint="MSMainTyped64" Text="@CS"/>
    <Shader Name="VSTY64" Target="vs_6_6" EntryPoint="VSMainTyped64" Text="@CS"/>
    <Shader Name="CSTY64" Target="cs_6_6" EntryPoint="CSMainTyped64" Text="@CS"/>
    <Shader Name="ASSH64" Target="as_6_6" EntryPoint="ASMainShared64" Text="@CS"/>
    <Shader Name="MSSH64" Target="ms_6_6" EntryPoint="MSMainShared64" Text="@CS"/>
    <Shader Name="CSSH64" Target="cs_6_6" EntryPoint="CSMainShared64" Text="@CS"/>
    <Shader Name="AS"   Target="as_6_5" EntryPoint="ASMain"   Text="@CS"/>
    <Shader Name="MS"   Target="ms_6_5" EntryPoint="MSMain"   Text="@CS"/>
    <Shader Name="VS"   Target="vs_6_0" EntryPoint="VSMain"   Text="@CS"/>
    <Shader Name="PS"   Target="ps_6_0" EntryPoint="PSMain"   Text="@CS"/>
    <Shader Name="CS"   Target="cs_6_0" EntryPoint="CSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        struct AtomicStuff {
          float2 prepad[3];
          uint uintEl[4];
          int4  sintEl;
          struct useless {
            uint3 unused;
          } postpad;
          float last;
        };
        struct Atomic64Stuff {
          float2 prepad[3];
          uint64_t uintEl[2];
          int64_t2  sintEl;
          struct useless {
            uint3 unused;
          } postpad;
          float last;
        };
        RWStructuredBuffer<AtomicStuff> g_structBuf : register(u0);
        RWStructuredBuffer<AtomicStuff> g_strXchgBuf : register(u1);

        RWByteAddressBuffer g_rawBuf : register(u2);
        RWByteAddressBuffer g_rawXchgBuf : register(u3);

        RWBuffer<uint> g_uintBuf : register(u4);
        RWBuffer<int> g_sintBuf : register(u5);
        RWBuffer<int> g_xchgBuf : register(u6);

        RWTexture1D<uint> g_utexBuf : register(u7);
        RWTexture1D<int> g_stexBuf : register(u8);
        RWTexture1D<int> g_xtexBuf : register(u9);

        RWBuffer<uint2> g_shareBuf : register(u10);
        RWBuffer<uint2> g_shareXchgBuf : register(u11);

        groupshared uint g_uintShare[12];
        groupshared int g_sintShare[6];
        groupshared uint g_xchgShare[128];

        RWStructuredBuffer<Atomic64Stuff> g_struct64Buf : register(u0);
        RWStructuredBuffer<Atomic64Stuff> g_strXchg64Buf : register(u1);

        RWByteAddressBuffer g_raw64Buf : register(u2);
        RWByteAddressBuffer g_rawXchg64Buf : register(u3);

        RWBuffer<uint64_t> g_uint64Buf : register(u12);
        RWBuffer<int64_t> g_sint64Buf : register(u13);
        RWBuffer<int64_t> g_xchg64Buf : register(u14);

        RWTexture1D<uint64_t> g_utex64Buf : register(u15);
        RWTexture1D<int64_t> g_stex64Buf : register(u16);
        RWTexture1D<int64_t> g_xtex64Buf : register(u17);

        RWBuffer<uint64_t> g_share64Buf : register(u10);
        RWBuffer<uint64_t> g_shareXchg64Buf : register(u11);

        groupshared uint64_t g_uint64Share[6];
        groupshared int64_t g_sint64Share[3];
        groupshared uint64_t g_xchg64Share[64];

        #define VEC_CALL(op, uav, ix, val) op(uav[ix*stride], val);

        #define USTRUCT_CALL(op, uav, ix, val) op(uav[ix].uintEl[stride], val);
        #define SSTRUCT_CALL(op, uav, ix, val) op(uav[ix].sintEl.z, val);
        #define SSTRUCT64_CALL(op, uav, ix, val) op(uav[ix].sintEl.y, val);

        #define URAW_CALL(op, uav, ix, val) uav.op(8*ix, val);
        #define SRAW_CALL(op, uav, ix, val) uav.op(8*(5+ix), val); // signed at end. raw buffers don't need separate buffers

        #define OP_TEST(ucall, scall, uuav, suav) \
          ucall(InterlockedAdd, uuav, 0, addVal); \
          scall(InterlockedMin, suav, 1, sminMaxVal); \
          scall(InterlockedMax, suav, 2, sminMaxVal); \
          ucall(InterlockedMin, uuav, 1, uminMaxVal); \
          ucall(InterlockedMax, uuav, 2, uminMaxVal); \
          ucall(InterlockedAnd, uuav, 3, ~value); \
          ucall(InterlockedOr,  uuav, 4, value); \
          ucall(InterlockedXor, uuav, 5, xorVal);

        #define VEC_CALL3(op, uav, ix, cmp, val) op(uav[(ix)*stride], cmp, val)
        #define VEC_CALL4(op, uav, ix, cmp, val, o) op(uav[(ix)*stride], cmp, val, o)

        #define STRUCT_CALL3(op, uav, ix, cmp, val) op(uav[ix].uintEl[stride], cmp, val)
        #define STRUCT_CALL4(op, uav, ix, cmp, val, o) op(uav[ix].uintEl[stride], cmp, val, o)

        #define RAW_CALL3(op, uav, ix, cmp, val) uav.op(8*(ix), cmp, val)
        #define RAW_CALL4(op, uav, ix, cmp, val, o) uav.op(8*(ix), cmp, val, o)

        // The first of four to match gets the first and then the winner performs the last two exchanges
        #define XCHG_TEST(call3, call4, uav) \
          call3(InterlockedCompareStore,    uav, (ix/3)%64, 0,           xchgVal - 2); \
          call4(InterlockedCompareExchange, uav, (ix/3)%64, xchgVal - 2, xchgVal - 1, output); \
          if (output == xchgVal - 2) { call3(InterlockedExchange, uav, (ix/3)%64, xchgVal, output);}

        void AtomicTest(uint ix, uint bitSize) {
          uint stride = 2;
          uint value = (ix) | ((ix) << (bitSize/2));
          uint addVal = ix; // 32 bits isn't enough room to dupliate upper and lower
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1U << (ix%(bitSize-1));
          // make higher bits differ while lower bits match
          uint xchgVal = (ix << (bitSize/2)) | ((ix/3)%64);
          uint output = 0;

          // structured
          OP_TEST(USTRUCT_CALL, SSTRUCT_CALL, g_structBuf, g_structBuf)
          XCHG_TEST(STRUCT_CALL3, STRUCT_CALL4, g_strXchgBuf)

          // raw
          OP_TEST(URAW_CALL, SRAW_CALL, g_rawBuf, g_rawBuf)
          XCHG_TEST(RAW_CALL3, RAW_CALL4, g_rawXchgBuf)

          // typed buffer
          OP_TEST(VEC_CALL, VEC_CALL, g_uintBuf, g_sintBuf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgBuf)

          // texture
          OP_TEST(VEC_CALL, VEC_CALL, g_utexBuf, g_stexBuf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xtexBuf)
        }

        void AtomicRaw64Test(uint ix, uint64_t bitSize) {
          uint64_t lix = ix;
          uint stride = 1;
          uint64_t value = (lix) | ((lix) << (bitSize/2));
          uint64_t addVal = value;
          uint64_t uminMaxVal = ~value*(~value&1) + value*(value&1);
          int64_t sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint64_t xorVal = 1ULL << (lix%(bitSize-1));
          // make higher bits differ while lower bits match
          uint64_t xchgVal = (lix << (bitSize/2)) | ((lix/3)%64);
          uint64_t output = 0;

          OP_TEST(USTRUCT_CALL, SSTRUCT64_CALL, g_struct64Buf, g_struct64Buf)
          XCHG_TEST(STRUCT_CALL3, STRUCT_CALL4, g_strXchg64Buf)

          // ByteAddressBuffer for 64-bit values are a special case. inlined here
          URAW_CALL(InterlockedAdd64, g_raw64Buf, 0, addVal);
          SRAW_CALL(InterlockedMin64, g_raw64Buf, 1, sminMaxVal);
          SRAW_CALL(InterlockedMax64, g_raw64Buf, 2, sminMaxVal);
          URAW_CALL(InterlockedMin64, g_raw64Buf, 1, uminMaxVal);
          URAW_CALL(InterlockedMax64, g_raw64Buf, 2, uminMaxVal);
          URAW_CALL(InterlockedAnd64, g_raw64Buf, 3, ~value);
          URAW_CALL(InterlockedOr64,  g_raw64Buf, 4, value);
          URAW_CALL(InterlockedXor64, g_raw64Buf, 5, xorVal);

          RAW_CALL3(InterlockedCompareStore64,    g_rawXchg64Buf, (ix/3)%64, 0,           xchgVal - 2);
          RAW_CALL4(InterlockedCompareExchange64, g_rawXchg64Buf, (ix/3)%64, xchgVal - 2, xchgVal - 1, output);
          if (output == xchgVal - 2) { RAW_CALL3(InterlockedExchange64, g_rawXchg64Buf, (ix/3)%64, xchgVal, output);}
        }

        void AtomicTyped64Test(uint ix, uint64_t bitSize) {
          uint64_t lix = ix;
          uint stride = 1;
          uint64_t value = (lix) | ((lix) << (bitSize/2));
          uint64_t addVal = value;
          uint64_t uminMaxVal = ~value*(~value&1) + value*(value&1);
          int64_t sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint64_t xorVal = 1ULL << (lix%(bitSize-1));
          // make higher bits differ while lower bits match
          uint64_t xchgVal = (lix << (bitSize/2)) | ((lix/3)%64);
          uint64_t output = 0;

          OP_TEST(VEC_CALL, VEC_CALL, g_uint64Buf, g_sint64Buf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchg64Buf)

          OP_TEST(VEC_CALL, VEC_CALL, g_utex64Buf, g_stex64Buf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xtex64Buf)
        }

        void InitSharedMem(uint ix) {
          // Zero-init shared memory, with special cases
          if (ix < 6)
            g_uintShare[ix] = ix == 1 ? 99999999 : ix == 3 ? -1 : 0;
          if (ix < 3)
            g_sintShare[ix] = ix == 1 ? 99999999 : 0;
          if (ix < 64)
            g_xchgShare[ix] = 0;

          GroupMemoryBarrierWithGroupSync();
        }

        void InitSharedMem64(uint ix) {
          // Zero-init shared memory, with special cases
          if (ix < 6)
            g_uint64Share[ix] = ix == 1 ? 99999999ULL | (99999999ULL << 32) : ix == 3 ? ~0ULL : 0;
          if (ix < 3)
            g_sint64Share[ix] = ix == 1 ? 99999999ULL | (99999999ULL << 32) : 0;
          if (ix < 64)
            g_xchg64Share[ix] = 0;

          GroupMemoryBarrierWithGroupSync();
        }

        void AtomicGroupSharedTest(uint ix) {
          uint stride = 1;
          uint bitSize = 32;
          uint value = (ix) | ((ix) << (bitSize/2));
          uint addVal = ix; // 32 bits isn't enough room to dupliate upper and lower
          uint uminMaxVal = ~value*(~value&1) + value*(value&1);
          int sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint xorVal = 1U << (ix%(bitSize-1));
          uint xchgVal = (ix << (bitSize/2)) | ((ix/3)%64);
          uint output = 0;

          OP_TEST(VEC_CALL, VEC_CALL, g_uintShare, g_sintShare)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgShare)

          GroupMemoryBarrierWithGroupSync();
        }

        void AtomicGroupShared64Test(uint ix) {
          uint64_t lix = ix;
          uint stride = 1;
          uint64_t bitSize = 64;
          uint64_t value = (lix) | ((lix) << (bitSize/2));
          uint64_t addVal = value;
          uint64_t uminMaxVal = ~value*(~value&1) + value*(value&1);
          int64_t sminMaxVal = ~value*(~value&1) + value*(value&1);
          uint64_t xorVal = 1ULL << (lix%(bitSize-1));
          uint64_t xchgVal = (lix << (bitSize/2)) | ((lix/3)%64);
          uint64_t output = 0;

          OP_TEST(VEC_CALL, VEC_CALL, g_uint64Share, g_sint64Share)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchg64Share)

          GroupMemoryBarrierWithGroupSync();
        }

        // Payloads are used to transport AS test results to MS where they are finalized
        struct Payload {
          uint arith[16];
          uint xchg[64];
        };

        struct Payload64 {
          uint64_t arith[16];
          uint64_t xchg[64];
        };

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        groupshared Payload payload;

        [NumThreads(8, 8, 2)]
        void ASMain(uint ix : SV_GroupIndex) {
          AtomicTest(64*64 + 8*8*2 + ix, 32);

          InitSharedMem(ix);
          AtomicGroupSharedTest(ix);

          // Copy AS test results to payload and ultimately to MS
          // More threads than results are possible,
          // so indices will result in duplicate copies
          payload.arith[ix%6] = g_uintShare[ix%6];
          payload.arith[ix%3 + 6] = g_sintShare[ix%3 + 1];
          payload.xchg[ix%64] = g_xchgShare[ix%64];

          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);

            AtomicTest(64*64 + ix, 32);

            // Load AS test results from payload
            // More threads than results are possible,
            // so indices will result in duplicate copies
            g_uintShare[ix%6] = payload.arith[ix%6];
            g_sintShare[ix%3] = payload.arith[ix%3 + 6];
            g_xchgShare[ix%64] = payload.xchg[ix%64];

            GroupMemoryBarrierWithGroupSync();

            AtomicGroupSharedTest(8*8*2 + ix);

            // Copy final AS + MS results to output UAVs
            g_shareBuf[ix%6].x = g_uintShare[ix%6];
            g_shareBuf[ix%3 + 6].x = g_sintShare[ix%3 + 1];
            g_shareXchgBuf[ix%64].x = g_xchgShare[ix%64];
        }

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicTest(64*64 + ix, 32);
          return result;
        }

        float4 PSMain(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicTest(ix, 32);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMain(uint ix : SV_GroupIndex) {
          AtomicTest(ix, 32);
          InitSharedMem(ix);
          AtomicGroupSharedTest(ix);

          g_shareBuf[ix%6].x = g_uintShare[ix%6];
          g_shareBuf[ix%3 + 6].x = g_sintShare[ix%3 + 1];

          g_shareXchgBuf[ix%64].x = g_xchgShare[ix%64];
        }

        [NumThreads(8, 8, 2)]
        void ASMain64(uint ix : SV_GroupIndex) {
          AtomicRaw64Test(64*64 + 8*8*2 + ix, 64);
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMain64(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);
            AtomicRaw64Test(64*64 + ix, 64);
        }

        PSInput VSMain64(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicRaw64Test(64*64 + ix, 64);
          return result;
        }

        float4 PSMain64(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicRaw64Test(ix, 64);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMain64(uint ix : SV_GroupIndex) {
          AtomicRaw64Test(ix, 64);
        }

        [NumThreads(8, 8, 2)]
        void ASMainTyped64(uint ix : SV_GroupIndex) {
          AtomicTyped64Test(64*64 + 8*8*2 + ix, 64);
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMainTyped64(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);
            AtomicTyped64Test(64*64 + ix, 64);
        }

        PSInput VSMainTyped64(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicTyped64Test(64*64 + ix, 64);
          return result;
        }

        float4 PSMainTyped64(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicTyped64Test(ix, 64);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMainTyped64(uint ix : SV_GroupIndex) {
          AtomicTyped64Test(ix, 64);
        }

        groupshared Payload64 payload64;

        [NumThreads(8, 8, 2)]
        void ASMainShared64(uint ix : SV_GroupIndex) {
          InitSharedMem64(ix);
          AtomicGroupShared64Test(ix);

          // Copy AS test results to payload and ultimately to MS
          // More threads than results are possible,
          // so indices will result in duplicate copies
          payload64.arith[ix%6] = g_uint64Share[ix%6];
          payload64.arith[ix%3 + 6] = g_sint64Share[ix%3 + 1];
          payload64.xchg[ix%64] = g_xchg64Share[ix%64];

          DispatchMesh(1, 1, 1, payload64);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMainShared64(
          uint ix : SV_GroupIndex,
          in payload Payload64 payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);

            // Load AS test results from payload
            // More threads than results are possible,
            // so indices will result in duplicate copies
            g_uint64Share[ix%6] = payload.arith[ix%6];
            g_sint64Share[ix%3] = payload.arith[ix%3 + 6];
            g_xchg64Share[ix%64] = payload.xchg[ix%64];

            GroupMemoryBarrierWithGroupSync();

            AtomicGroupShared64Test(8*8*2 + ix);

            // Copy final AS + MS results to output UAVs
            g_share64Buf[ix%6] = g_uint64Share[ix%6];
            g_share64Buf[ix%3 + 6] = g_sint64Share[ix%3 + 1];
            g_shareXchg64Buf[ix%64] = g_xchg64Share[ix%64];

        }

        [NumThreads(32, 32, 1)]
        void CSMainShared64(uint ix : SV_GroupIndex) {
          InitSharedMem64(ix);
          AtomicGroupShared64Test(ix);

          // Copy final results to output UAVs
          g_share64Buf[ix%6] = g_uint64Share[ix%6];
          g_share64Buf[ix%3 + 6] = g_sint64Share[ix%3 + 1];
          g_shareXchg64Buf[ix%64] = g_xchg64Share[ix%64];

        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="FloatAtomics" PS="PS" VS="VS" CS="CS" AS="AS" MS="MS" TopologyType="TRIANGLE">
    <RootSignature>
      RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),
      DescriptorTable(UAV(u0), UAV(u1), UAV(u2), UAV(u3), UAV(u4)),
      StaticSampler(s0, addressU = TEXTURE_ADDRESS_WRAP, addressV = TEXTURE_ADDRESS_WRAP, filter = FILTER_MIN_MAG_LINEAR_MIP_POINT)
    </RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
      { { -1.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },

      { { -1.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
      { { 1.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } },
      { { 1.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } }
    </Resource>
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="64" Height="64" Format="R32G32B32A32_FLOAT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" />
    <Resource Name="U0" Dimension="BUFFER" Width="2816"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U1" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U2" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U3" Dimension="TEXTURE1D" Width="64" Format="R32_FLOAT"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <Resource Name="U4" Dimension="BUFFER" Width="256"
              Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST"
              Init="Zero" ReadBack="true" />
    <RootValues>
      <RootValue HeapName="ResHeap" />
    </RootValues>
    <DescriptorHeap Name="ResHeap" Type="CBV_SRV_UAV">
      <Descriptor Name="U0" Kind="UAV" ResName="U0"
                  NumElements="64" StructureByteStride="44" />
      <Descriptor Name="U1" Kind="UAV" ResName="U1"
                  NumElements="64" StructureByteStride="4" />
      <Descriptor Name="U2" Kind="UAV" ResName="U2"
                  NumElements="64" Format="R32_FLOAT" />
      <Descriptor Name="U3" Kind="UAV" ResName="U3" Dimension="TEXTURE1D"
                  NumElements="64" Format="R32_FLOAT" />
      <Descriptor Name="U4" Kind="UAV" ResName="U4"
                  NumElements="64" Format="R32_FLOAT" />
    </DescriptorHeap>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>

    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      <InputElement SemanticName="TEXCOORD" Format="R32G32_FLOAT" AlignedByteOffset="12" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget"/>
    </RenderTargets>
    <Shader Name="AS"   Target="as_6_5" EntryPoint="ASMain"   Text="@CS"/>
    <Shader Name="MS"   Target="ms_6_5" EntryPoint="MSMain"   Text="@CS"/>
    <Shader Name="VS"   Target="vs_6_0" EntryPoint="VSMain"   Text="@CS"/>
    <Shader Name="PS"   Target="ps_6_0" EntryPoint="PSMain"   Text="@CS"/>
    <Shader Name="CS"   Target="cs_6_0" EntryPoint="CSMain">
      <![CDATA[
        struct PSInput {
          float4 position : SV_POSITION;
          float2 uv : TEXCOORD;
        };
        struct AtomicStuff {
          float2 prepad[3];
          float fltEl[2];
          struct useless {
            uint3 unused;
          } postpad;
        };

        RWStructuredBuffer<AtomicStuff> g_strXchgBuf : register(u0);
        RWByteAddressBuffer g_rawXchgBuf : register(u1);
        RWBuffer<float> g_xchgBuf : register(u2);
        RWTexture1D<float> g_xtexBuf : register(u3);
        RWBuffer<float> g_shareXchgBuf : register(u4);

        groupshared float g_xchgShare[1024];

        #define VEC_CALL3(op, uav, ix, cmp, val) op(uav[(ix)], cmp, val)
        #define VEC_CALL4(op, uav, ix, cmp, val, o) op(uav[(ix)], cmp, val, o)

        #define STRUCT_CALL3(op, uav, ix, cmp, val) op(uav[ix].fltEl[1], cmp, val)
        #define STRUCT_CALL4(op, uav, ix, cmp, val, o) op(uav[ix].fltEl[1], cmp, val, o)

        #define RAW_CALL3(op, uav, ix, cmp, val) uav.op(4*(ix), cmp, val)
        #define RAW_CALL4(op, uav, ix, cmp, val, o) uav.op(4*(ix), cmp, val, o)

        // The first of four to match gets the first and then the winner performs the last two exchanges
        #define XCHG_TEST(call3, call4, uav) \
          call3(InterlockedCompareStoreFloatBitwise,    uav, (ix/3)%63 + 1, 0,           xchgVal - 2); \
          call4(InterlockedCompareExchangeFloatBitwise, uav, (ix/3)%63 + 1, xchgVal - 2, xchgVal - 1, output); \
          if (output == xchgVal - 2) { call3(InterlockedExchange, uav, (ix/3)%63 + 1, xchgVal, output);}

        void AtomicTest(uint ix) {
          float xchgVal = ix;
          float output = 0;

          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgBuf)
          XCHG_TEST(STRUCT_CALL3, STRUCT_CALL4, g_strXchgBuf)
          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xtexBuf)

          // Special case for ByteAddressBuffers
          RAW_CALL3(InterlockedCompareStoreFloatBitwise,    g_rawXchgBuf, (ix/3)%63 + 1, 0,           xchgVal - 2);
          RAW_CALL4(InterlockedCompareExchangeFloatBitwise, g_rawXchgBuf, (ix/3)%63 + 1, xchgVal - 2, xchgVal - 1, output);
          if (output == xchgVal - 2) { RAW_CALL3(InterlockedExchangeFloat, g_rawXchgBuf, (ix/3)%63 + 1, xchgVal, output);}

          // Check NaN corner case
          InterlockedCompareExchangeFloatBitwise(g_xchgBuf[0], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_xchgBuf[0], sqrt(-1), 0.123);

          InterlockedCompareExchangeFloatBitwise(g_strXchgBuf[0].fltEl[1], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_strXchgBuf[0].fltEl[1], sqrt(-1), 0.123);

          g_rawXchgBuf.InterlockedCompareExchangeFloatBitwise(0, 0, sqrt(-1), output);
          if (output == 0.0) g_rawXchgBuf.InterlockedCompareStoreFloatBitwise(0, sqrt(-1), 0.123);

          InterlockedCompareExchangeFloatBitwise(g_xtexBuf[0], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_xtexBuf[0], sqrt(-1), 0.123);
        }

        void InitSharedMem(uint ix) {
          // Zero-init shared memory
          g_xchgShare[ix%64] = 0;
          GroupMemoryBarrierWithGroupSync();
        }

        void AtomicGroupSharedTest(uint ix) {
          float xchgVal = ix;
          float output = 0;

          XCHG_TEST(VEC_CALL3, VEC_CALL4, g_xchgShare)

          InterlockedCompareExchangeFloatBitwise(g_xchgShare[0], 0, sqrt(-1), output);
          if (output == 0.0) InterlockedCompareStoreFloatBitwise(g_xchgShare[0], sqrt(-1), 0.123);

          GroupMemoryBarrierWithGroupSync();
        }

        // Payloads are used to transport AS test results to MS where they are finalized
        struct Payload {
          float xchg[64];
        };

        static float4 g_Verts[6] = {
          { -1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          { -1.0f, -1.0f, 0.0f, 1.0f },

          { -1.0f, -1.0f, 0.0f, 1.0f },
          {  1.0f,  1.0f, 0.0f, 1.0f },
          {  1.0f, -1.0f, 0.0f, 1.0f }};

        static float2 g_UV[6] = {
          { 0.0f, 0.0f },
          { 1.0f, 0.0f },
          { 0.0f, 1.0f },

          { 0.0f, 1.0f },
          { 1.0f, 0.0f },
          { 1.0f, 1.0f }};

        groupshared Payload payload;

        [NumThreads(8, 8, 2)]
        void ASMain(uint ix : SV_GroupIndex) {
          AtomicTest(64*64 + 8*8*2 + ix);

          InitSharedMem(ix);
          AtomicGroupSharedTest(ix);

          // Copy AS test results to payload and ultimately to MS
          // More threads than results are possible,
          // so indices will result in duplicate copies
          payload.xchg[ix%64] = g_xchgShare[ix%64];
          DispatchMesh(1, 1, 1, payload);
        }

        [NumThreads(8, 8, 2)]
        [OutputTopology("triangle")]
        void MSMain(
          uint ix : SV_GroupIndex,
          in payload Payload payload,
          out vertices PSInput verts[6],
          out indices uint3 tris[2]) {
            SetMeshOutputCounts(6, 2);
            // Assign static fullscreen 2 tri quad
            verts[ix%6].position = g_Verts[ix%6];
            verts[ix%6].uv = g_UV[ix%6];
            tris[ix&1] = uint3((ix&1)*3, (ix&1)*3 + 1, (ix&1)*3 + 2);

            AtomicTest(64*64 + ix);

            // Load AS test results from payload
            // More threads than results are possible,
            // so indices will result in duplicate copies
            g_xchgShare[ix%64] = payload.xchg[ix%64];
            GroupMemoryBarrierWithGroupSync();

            AtomicGroupSharedTest(8*8*2 + ix);

            // Copy final AS + MS results to output UAVs
            g_shareXchgBuf[ix%64] = g_xchgShare[ix%64];
        }

        PSInput VSMain(float3 position : POSITION, float2 uv : TEXCOORD, uint ix : SV_VertexID) {
          PSInput result;
          result.position = float4(position, 1.0);
          result.uv = uv;
          AtomicTest(64*64 + ix);
          return result;
        }

        float4 PSMain(PSInput input) : SV_TARGET {
          uint ix = uint(input.uv.y*64)*64 + input.uv.x*64;
          AtomicTest(ix);
          return 1;
        }

        [NumThreads(32, 32, 1)]
        void CSMain(uint ix : SV_GroupIndex) {
          AtomicTest(ix);

          InitSharedMem(ix);
          AtomicGroupSharedTest(ix);

          g_shareXchgBuf[ix%64] = g_xchgShare[ix%64];
        }
      ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="HelperLaneTestNoWave" PS="PS" VS="VS" TopologyType="TRIANGLE">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), UAV(u0)</RootSignature>
    <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
        { { -1.0f,  1.0f, 0.0f } },
        { {  1.0f,  1.0f, 0.0f } },
        { {  1.0f, -1.0f, 0.0f } },
    </Resource>
    <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="120" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
    <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
    <RootValues>
        <RootValue Index="0" ResName="UAVBuffer0" />
    </RootValues>
    <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
      <Descriptor Name="RTarget" Kind="RTV"/>
    </DescriptorHeap>
    <InputElements>
      <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
    </InputElements>
    <RenderTargets>
      <RenderTarget Name="RTarget">
        <Viewport Width="2.0" Height="2.0" MaxDepth="1.0"/>
      </RenderTarget>
    </RenderTargets>
    <Shader Name="VS" Target="vs_6_0" EntryPoint="VSMain" Text="@PS" />
    <Shader Name="PS" Target="ps_6_0" EntryPoint="PSMain">
        <![CDATA[
#ifdef ISHELPERLANE_PLACEHOLDER
        bool ph_IsHelperLane(float4 pos, bool first_call) {
            if (first_call) {
                return pos.x < 1.0f && pos.y > 1.0f;
            }
            else {
                return pos.x < 1.0f;
            }
        }
#endif // ISHELPERLANE_PLACEHOLDER

        struct HelperLaneTestResult{
            int is_helper_00;
            int is_helper_10;
            int is_helper_01;
            int is_helper_11;
        };
        
        RWStructuredBuffer<HelperLaneTestResult> g_testResults : register(u0);
        
        int ReadAcrossX_DD(int value, bool isLeft) {
          int d = ddx_fine(value);
          return isLeft ? value + d : value - d;
        }
        
        int ReadAcrossY_DD(int value, bool isTop) {
          int d = ddy_fine(value);
          return isTop ? value + d : value - d;
        }
        
        int ReadAcrossDiagonal_DD(int value, bool isLeft, bool isTop) {
          return ReadAcrossY_DD(ReadAcrossX_DD(value, isLeft), isTop);
        }

        struct PSInput {
            float4 pos : SV_POSITION;
        };
        
        PSInput VSMain(float3 pos : POSITION) {
            PSInput r;
            r.pos = float4(pos, 1); 
            return r;
        }

        uint4 PSMain(PSInput input) : SV_TARGET {
          bool isLeft = (input.pos.x < 1.0f);
          bool isTop = (input.pos.y < 1.0f);
          
          for (int i = 0; i < 2; i++) {
#ifdef ISHELPERLANE_PLACEHOLDER
            int is_helper = ph_IsHelperLane(input.pos, i == 0);
#else
            int is_helper = IsHelperLane();
#endif
            int is_helper_accross_X = ReadAcrossX_DD(is_helper, isLeft);
            int is_helper_accross_Y = ReadAcrossY_DD(is_helper, isTop);
            int is_helper_accross_Diag = ReadAcrossDiagonal_DD(is_helper, isLeft, isTop);
          
            if (!isLeft && !isTop) { //bottom right pixel writes results
              g_testResults[i].is_helper_00 = is_helper_accross_Diag;
              g_testResults[i].is_helper_10 = is_helper_accross_Y;
              g_testResults[i].is_helper_01 = is_helper_accross_X;
              g_testResults[i].is_helper_11 = is_helper;
            }

            if (i == 0 && isLeft && isTop) // discard top left pixel
              discard;
          }
          return uint4(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 1);
        }
        ]]>
    </Shader>
  </ShaderOp>

  <ShaderOp Name="HelperLaneTestWave" CS="CS" PS="PS" VS="VS" DispatchX="3" DispatchY="1" TopologyType="TRIANGLE">
    <RootSignature>RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT), UAV(u0)</RootSignature>
      <Resource Name="VBuffer" Dimension="BUFFER" InitialResourceState="COPY_DEST" Init="FromBytes" Topology="TRIANGLELIST">
            { { -1.0f,  1.0f, 0.0f } },
            { {  1.0f,  1.0f, 0.0f } },
            { {  1.0f, -1.0f, 0.0f } },
      </Resource>
      <Resource Name="UAVBuffer0" Dimension="BUFFER" Width="1024" Flags="ALLOW_UNORDERED_ACCESS" InitialResourceState="COPY_DEST" TransitionTo="UNORDERED_ACCESS" Init="ByName" ReadBack="true" Format="R32_TYPELESS" />
      <Resource Name="RTarget" Dimension="TEXTURE2D" Width="16" Height="16" Format="R32G32B32A32_UINT" Flags="ALLOW_RENDER_TARGET" InitialResourceState="COPY_DEST" ReadBack="true" />
      <RootValues>
        <RootValue Index="0" ResName="UAVBuffer0" />
      </RootValues>
      <DescriptorHeap Name="RtvHeap" NumDescriptors="1" Type="RTV">
         <Descriptor Name="RTarget" Kind="RTV"/>
      </DescriptorHeap>
      <InputElements>
         <InputElement SemanticName="POSITION" Format="R32G32B32_FLOAT" AlignedByteOffset="0" />
      </InputElements>
      <RenderTargets>
          <RenderTarget Name="RTarget">
              <Viewport Width="2.0" Height="2.0" MaxDepth="1.0"/>
          </RenderTarget>
      </RenderTargets>
      <Shader Name="PS65" Target="ps_6_5" EntryPoint="PSMain65" Text="@CS"/>
      <Shader Name="VS65" Target="vs_6_5" EntryPoint="VSMain65" Text="@CS"/>
      <Shader Name="CS65" Target="cs_6_5" EntryPoint="CSMain65" Text="@CS"/>
      <Shader Name="PS66" Target="ps_6_6" EntryPoint="PSMain65" Text="@CS"/>
      <Shader Name="VS66" Target="vs_6_6" EntryPoint="VSMain65" Text="@CS"/>
      <Shader Name="CS66" Target="cs_6_6" EntryPoint="CSMain65" Text="@CS"/>
      <Shader Name="VS"   Target="vs_6_0" EntryPoint="VSMain"   Text="@CS"/>
      <Shader Name="PS"   Target="ps_6_0" EntryPoint="PSMain"   Text="@CS"/>
      <Shader Name="CS"   Target="cs_6_0" EntryPoint="CSMain">
        <![CDATA[
#ifdef ISHELPERLANE_PLACEHOLDER
        #define CALL(x) ph_##x
        
        bool ph_IsHelperLane() {
            return false;
        }

        bool ph_IsHelperLane(float4 pos, bool first_call) {
            if (first_call) {
                return pos.x < 1.0f && pos.y > 1.0f;
            }
            else {
                return pos.x < 1.0f;
            }
        }
#else
        #define CALL(x) x
#endif

        // 6.0 wave ops
        struct HelperLaneWaveTestResult60 {
            int anyTrue;
            int allTrue;
            uint4 ballot;
            int waterfallLoopCount;
            int allEqual;
            int countBits;
            int sum;
            int product;
            int bitAnd;
            int bitOr;
            int bitXor;
            int min;
            int max;
            int prefixCountBits;
            int prefixProduct;
            int prefixSum;
        };
        
        struct HelperLaneQuadTestResult {
            int is_helper_this;
            int is_helper_across_X;
            int is_helper_across_Y;
            int is_helper_across_Diag;
        };
        
        // 6.5 wave ops
        struct HelperLaneWaveTestResult65 {
            uint4 match;
            int mpCountBits;
            int mpSum;
            int mpProduct;
            int mpBitAnd;
            int mpBitOr;
            int mpBitXor;
        };
        
        struct HelperLaneWaveTestResult {
            HelperLaneWaveTestResult60 sm60_wave;
            HelperLaneQuadTestResult sm60_quad;
            HelperLaneWaveTestResult65 sm65_wave;
        };
        
        RWStructuredBuffer<HelperLaneWaveTestResult> g_TestResults : register(u0);
        
        #define CS_INDEX    0
        #define VS_INDEX    0
        #define PS_INDEX    1
        #define PS_INDEX_AFTER_DISCARD 2
        
        HelperLaneWaveTestResult60 RunHelperLaneWaveTests60() {
            HelperLaneWaveTestResult60 tr;
            bool is_helper = CALL(IsHelperLane());
            tr.anyTrue = WaveActiveAnyTrue(is_helper);
            tr.allTrue = WaveActiveAllTrue(!is_helper);
            tr.ballot = WaveActiveBallot(true);

            // waterfall loop
            int count = 0;
            int waveCount = WaveGetLaneCount();
            while (count < waveCount) {
                count++;
                if (WaveReadLaneFirst(!CALL(IsHelperLane())) && WaveIsFirstLane()) {
                    break;
                }
            }
            tr.waterfallLoopCount = count;
            
            is_helper = CALL(IsHelperLane());
            tr.allEqual = WaveActiveAllEqual(is_helper);
            tr.countBits = WaveActiveCountBits(true);
            tr.sum = WaveActiveSum(4);
            tr.product = WaveActiveProduct(4);
            tr.bitAnd = WaveActiveBitAnd((uint)!is_helper);
            tr.bitOr = WaveActiveBitOr((uint)is_helper);
            tr.bitXor = WaveActiveBitXor((uint)is_helper);
            tr.min = WaveActiveMin(is_helper ? 1 : 10);
            tr.max = WaveActiveMax(is_helper ? 10 : 1);
            tr.prefixCountBits = WavePrefixCountBits(1);
            tr.prefixProduct = WavePrefixProduct(4);
            tr.prefixSum = WavePrefixSum(2);

            return tr;
        }
        
        HelperLaneQuadTestResult RunHelperLaneQuadTests() {
            HelperLaneQuadTestResult tr;
            int is_helper = CALL(IsHelperLane());

            tr.is_helper_this = is_helper;
            tr.is_helper_across_X = QuadReadAcrossX(is_helper);
            tr.is_helper_across_Y = QuadReadAcrossY(is_helper);
            tr.is_helper_across_Diag = QuadReadAcrossDiagonal(is_helper);
            
            return tr;
        }
        
        #ifdef ISHELPERLANE_PLACEHOLDER
        HelperLaneQuadTestResult ph_RunHelperLaneQuadTests_PS(float4 pos, bool first_call) {
            HelperLaneQuadTestResult tr;
            
            int is_helper = ph_IsHelperLane(pos, first_call);
            tr.is_helper_this = is_helper;
            tr.is_helper_across_X = QuadReadAcrossX(is_helper);
            tr.is_helper_across_Y = QuadReadAcrossY(is_helper);
            tr.is_helper_across_Diag = QuadReadAcrossDiagonal(is_helper);
            
            return tr;
        }
        #endif

        HelperLaneWaveTestResult65 RunHelperLaneWaveTests65() {
            HelperLaneWaveTestResult65 tr;
            uint4 noMaskedBits = (uint4)0xFFFFFFFF;
            bool is_helper = CALL(IsHelperLane());

            tr.match = WaveMatch(true);
            tr.mpCountBits = WaveMultiPrefixCountBits(1, noMaskedBits);
            tr.mpSum = WaveMultiPrefixSum(2, noMaskedBits);
            tr.mpProduct = WaveMultiPrefixProduct(4, noMaskedBits);
            tr.mpBitAnd = WaveMultiPrefixBitAnd(is_helper ? 0 : 1, noMaskedBits);
            tr.mpBitOr = WaveMultiPrefixBitOr(is_helper ? 1 : 0, noMaskedBits);
            tr.mpBitXor = WaveMultiPrefixBitXor(is_helper ? 1 : 0, noMaskedBits);
            return tr;
        }
        
        struct PSInput {
            float4 pos : SV_POSITION;
        };
        
        PSInput VSMain(float3 pos : POSITION) {
            HelperLaneWaveTestResult60 tr60 = RunHelperLaneWaveTests60();
            if (WaveGetLaneIndex() == 2) { // last lane writes results
                g_TestResults[VS_INDEX].sm60_wave = tr60;
            }
            PSInput r;
            r.pos = float4(pos, 1); 
            return r;
        }
        
        PSInput VSMain65(float3 pos : POSITION) {
            HelperLaneWaveTestResult60 tr60 = RunHelperLaneWaveTests60();
            HelperLaneWaveTestResult65 tr65 = RunHelperLaneWaveTests65();
            if (WaveGetLaneIndex() == 2) { // last lane writes results
                g_TestResults[VS_INDEX].sm60_wave = tr60;
                g_TestResults[VS_INDEX].sm65_wave = tr65;
            }
            PSInput r;
            r.pos = float4(pos, 1); 
            return r;
        }

        uint4 PSMain(PSInput input) : SV_TARGET {
            HelperLaneWaveTestResult60 tr60 = RunHelperLaneWaveTests60();
            
        #ifdef ISHELPERLANE_PLACEHOLDER
            HelperLaneQuadTestResult tr60_quad = ph_RunHelperLaneQuadTests_PS(input.pos, true);
        #else
            HelperLaneQuadTestResult tr60_quad = RunHelperLaneQuadTests();
        #endif
        
            if (input.pos.x > 1.0f && input.pos.y > 1.0f) { // bottom right pixel writes results
                g_TestResults[PS_INDEX].sm60_wave = tr60;
                g_TestResults[PS_INDEX].sm60_quad = tr60_quad;
            }
            if (input.pos.x < 1.0f && input.pos.y < 1.0f) // discard top left pixel
                discard;
                
            HelperLaneWaveTestResult60 tr60_disc = RunHelperLaneWaveTests60();

#ifdef ISHELPERLANE_PLACEHOLDER
            HelperLaneQuadTestResult tr60_quad_disc  = ph_RunHelperLaneQuadTests_PS(input.pos, false);
#else
            HelperLaneQuadTestResult tr60_quad_disc = RunHelperLaneQuadTests();
#endif
            if (input.pos.x > 1.0f && input.pos.y > 1.0f) { // bottom right pixel writes results
                g_TestResults[PS_INDEX_AFTER_DISCARD].sm60_wave = tr60_disc;
                g_TestResults[PS_INDEX_AFTER_DISCARD].sm60_quad = tr60_quad_disc;
            }
            return uint4(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 1);
        }

        uint4 PSMain65(PSInput input) : SV_TARGET {
            HelperLaneWaveTestResult tr;
            tr.sm60_wave = RunHelperLaneWaveTests60();
#ifdef ISHELPERLANE_PLACEHOLDER
            tr.sm60_quad = ph_RunHelperLaneQuadTests_PS(input.pos, true);
#else
            tr.sm60_quad = RunHelperLaneQuadTests();
#endif
            tr.sm65_wave = RunHelperLaneWaveTests65();
            
            if (input.pos.x > 1.0f && input.pos.y > 1.0f) { // bottom right pixel writes results
                g_TestResults[PS_INDEX] = tr;
            }

            if (input.pos.x < 1.0f && input.pos.y < 1.0f) // discard top left pixel
                discard;
                
            HelperLaneWaveTestResult tr_disc;
            tr_disc.sm60_wave = RunHelperLaneWaveTests60();
#ifdef ISHELPERLANE_PLACEHOLDER
            tr_disc.sm60_quad = ph_RunHelperLaneQuadTests_PS(input.pos, false);
#else
            tr_disc.sm60_quad = RunHelperLaneQuadTests();
#endif
            tr_disc.sm65_wave = RunHelperLaneWaveTests65();
            
            if (input.pos.x > 1.0f && input.pos.y > 1.0f) { // bottom right pixel writes results
                g_TestResults[PS_INDEX_AFTER_DISCARD] = tr_disc;
            }
            return uint4(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 1);
        }
        
        [numthreads(3,1,1)]
        void CSMain(uint3 tid : SV_GroupThreadID) {
            HelperLaneWaveTestResult60 tr60 = RunHelperLaneWaveTests60();
            HelperLaneQuadTestResult tr60_quad = RunHelperLaneQuadTests();
            if (WaveGetLaneIndex() == 2) { // last lane writes results
                g_TestResults[CS_INDEX].sm60_wave = tr60;
                g_TestResults[CS_INDEX].sm60_quad = tr60_quad;
            }
        }
        
        [numthreads(3,1,1)]
        void CSMain65() {
            HelperLaneWaveTestResult tr;
            tr.sm60_wave = RunHelperLaneWaveTests60();
            tr.sm60_quad = RunHelperLaneQuadTests();
            tr.sm65_wave = RunHelperLaneWaveTests65();

            if (WaveGetLaneIndex() == 2) { // last lane writes results
                g_TestResults[CS_INDEX] = tr;
            }
        }
]]>
    </Shader>
  </ShaderOp>
</ShaderOpSet>
